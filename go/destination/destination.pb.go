// Code generated by protoc-gen-go. DO NOT EDIT.
// source: destination.proto

package destination // import "github.com/linkerd/linkerd2-proxy-api/go/destination"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import duration "github.com/golang/protobuf/ptypes/duration"
import http_types "github.com/linkerd/linkerd2-proxy-api/go/http_types"
import net "github.com/linkerd/linkerd2-proxy-api/go/net"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GetDestination struct {
	Scheme string `protobuf:"bytes,1,opt,name=scheme,proto3" json:"scheme,omitempty"`
	Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// An opaque value that is set at injection-time and sent with destintion lookups.
	//
	// If, for instance, the token encodes a namespace or some locality
	// information, the service may alter its results to take this locality into
	// account.
	ContextToken         string   `protobuf:"bytes,3,opt,name=context_token,json=contextToken,proto3" json:"context_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDestination) Reset()         { *m = GetDestination{} }
func (m *GetDestination) String() string { return proto.CompactTextString(m) }
func (*GetDestination) ProtoMessage()    {}
func (*GetDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{0}
}
func (m *GetDestination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetDestination.Unmarshal(m, b)
}
func (m *GetDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetDestination.Marshal(b, m, deterministic)
}
func (dst *GetDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDestination.Merge(dst, src)
}
func (m *GetDestination) XXX_Size() int {
	return xxx_messageInfo_GetDestination.Size(m)
}
func (m *GetDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDestination.DiscardUnknown(m)
}

var xxx_messageInfo_GetDestination proto.InternalMessageInfo

func (m *GetDestination) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *GetDestination) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GetDestination) GetContextToken() string {
	if m != nil {
		return m.ContextToken
	}
	return ""
}

type Update struct {
	// Types that are valid to be assigned to Update:
	//	*Update_Add
	//	*Update_Remove
	//	*Update_NoEndpoints
	Update               isUpdate_Update `protobuf_oneof:"update"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Update) Reset()         { *m = Update{} }
func (m *Update) String() string { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()    {}
func (*Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{1}
}
func (m *Update) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Update.Unmarshal(m, b)
}
func (m *Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Update.Marshal(b, m, deterministic)
}
func (dst *Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Update.Merge(dst, src)
}
func (m *Update) XXX_Size() int {
	return xxx_messageInfo_Update.Size(m)
}
func (m *Update) XXX_DiscardUnknown() {
	xxx_messageInfo_Update.DiscardUnknown(m)
}

var xxx_messageInfo_Update proto.InternalMessageInfo

type isUpdate_Update interface {
	isUpdate_Update()
}

type Update_Add struct {
	Add *WeightedAddrSet `protobuf:"bytes,1,opt,name=add,proto3,oneof"`
}

type Update_Remove struct {
	Remove *AddrSet `protobuf:"bytes,2,opt,name=remove,proto3,oneof"`
}

type Update_NoEndpoints struct {
	NoEndpoints *NoEndpoints `protobuf:"bytes,3,opt,name=no_endpoints,json=noEndpoints,proto3,oneof"`
}

func (*Update_Add) isUpdate_Update() {}

func (*Update_Remove) isUpdate_Update() {}

func (*Update_NoEndpoints) isUpdate_Update() {}

func (m *Update) GetUpdate() isUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Update) GetAdd() *WeightedAddrSet {
	if x, ok := m.GetUpdate().(*Update_Add); ok {
		return x.Add
	}
	return nil
}

func (m *Update) GetRemove() *AddrSet {
	if x, ok := m.GetUpdate().(*Update_Remove); ok {
		return x.Remove
	}
	return nil
}

func (m *Update) GetNoEndpoints() *NoEndpoints {
	if x, ok := m.GetUpdate().(*Update_NoEndpoints); ok {
		return x.NoEndpoints
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Update) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Update_OneofMarshaler, _Update_OneofUnmarshaler, _Update_OneofSizer, []interface{}{
		(*Update_Add)(nil),
		(*Update_Remove)(nil),
		(*Update_NoEndpoints)(nil),
	}
}

func _Update_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Update)
	// update
	switch x := m.Update.(type) {
	case *Update_Add:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Add); err != nil {
			return err
		}
	case *Update_Remove:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Remove); err != nil {
			return err
		}
	case *Update_NoEndpoints:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoEndpoints); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Update.Update has unexpected type %T", x)
	}
	return nil
}

func _Update_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Update)
	switch tag {
	case 1: // update.add
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WeightedAddrSet)
		err := b.DecodeMessage(msg)
		m.Update = &Update_Add{msg}
		return true, err
	case 2: // update.remove
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddrSet)
		err := b.DecodeMessage(msg)
		m.Update = &Update_Remove{msg}
		return true, err
	case 3: // update.no_endpoints
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NoEndpoints)
		err := b.DecodeMessage(msg)
		m.Update = &Update_NoEndpoints{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Update_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Update)
	// update
	switch x := m.Update.(type) {
	case *Update_Add:
		s := proto.Size(x.Add)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Update_Remove:
		s := proto.Size(x.Remove)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Update_NoEndpoints:
		s := proto.Size(x.NoEndpoints)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AddrSet struct {
	Addrs                []*net.TcpAddress `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AddrSet) Reset()         { *m = AddrSet{} }
func (m *AddrSet) String() string { return proto.CompactTextString(m) }
func (*AddrSet) ProtoMessage()    {}
func (*AddrSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{2}
}
func (m *AddrSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddrSet.Unmarshal(m, b)
}
func (m *AddrSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddrSet.Marshal(b, m, deterministic)
}
func (dst *AddrSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddrSet.Merge(dst, src)
}
func (m *AddrSet) XXX_Size() int {
	return xxx_messageInfo_AddrSet.Size(m)
}
func (m *AddrSet) XXX_DiscardUnknown() {
	xxx_messageInfo_AddrSet.DiscardUnknown(m)
}

var xxx_messageInfo_AddrSet proto.InternalMessageInfo

func (m *AddrSet) GetAddrs() []*net.TcpAddress {
	if m != nil {
		return m.Addrs
	}
	return nil
}

type WeightedAddrSet struct {
	Addrs                []*WeightedAddr   `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	MetricLabels         map[string]string `protobuf:"bytes,2,rep,name=metric_labels,json=metricLabels,proto3" json:"metric_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WeightedAddrSet) Reset()         { *m = WeightedAddrSet{} }
func (m *WeightedAddrSet) String() string { return proto.CompactTextString(m) }
func (*WeightedAddrSet) ProtoMessage()    {}
func (*WeightedAddrSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{3}
}
func (m *WeightedAddrSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WeightedAddrSet.Unmarshal(m, b)
}
func (m *WeightedAddrSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WeightedAddrSet.Marshal(b, m, deterministic)
}
func (dst *WeightedAddrSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedAddrSet.Merge(dst, src)
}
func (m *WeightedAddrSet) XXX_Size() int {
	return xxx_messageInfo_WeightedAddrSet.Size(m)
}
func (m *WeightedAddrSet) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedAddrSet.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedAddrSet proto.InternalMessageInfo

func (m *WeightedAddrSet) GetAddrs() []*WeightedAddr {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *WeightedAddrSet) GetMetricLabels() map[string]string {
	if m != nil {
		return m.MetricLabels
	}
	return nil
}

type WeightedAddr struct {
	Addr                 *net.TcpAddress   `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Weight               uint32            `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	MetricLabels         map[string]string `protobuf:"bytes,4,rep,name=metric_labels,json=metricLabels,proto3" json:"metric_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TlsIdentity          *TlsIdentity      `protobuf:"bytes,5,opt,name=tls_identity,json=tlsIdentity,proto3" json:"tls_identity,omitempty"`
	ProtocolHint         *ProtocolHint     `protobuf:"bytes,6,opt,name=protocol_hint,json=protocolHint,proto3" json:"protocol_hint,omitempty"`
	AuthorityOverride    string            `protobuf:"bytes,7,opt,name=authority_override,json=authorityOverride,proto3" json:"authority_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WeightedAddr) Reset()         { *m = WeightedAddr{} }
func (m *WeightedAddr) String() string { return proto.CompactTextString(m) }
func (*WeightedAddr) ProtoMessage()    {}
func (*WeightedAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{4}
}
func (m *WeightedAddr) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WeightedAddr.Unmarshal(m, b)
}
func (m *WeightedAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WeightedAddr.Marshal(b, m, deterministic)
}
func (dst *WeightedAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedAddr.Merge(dst, src)
}
func (m *WeightedAddr) XXX_Size() int {
	return xxx_messageInfo_WeightedAddr.Size(m)
}
func (m *WeightedAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedAddr.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedAddr proto.InternalMessageInfo

func (m *WeightedAddr) GetAddr() *net.TcpAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *WeightedAddr) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *WeightedAddr) GetMetricLabels() map[string]string {
	if m != nil {
		return m.MetricLabels
	}
	return nil
}

func (m *WeightedAddr) GetTlsIdentity() *TlsIdentity {
	if m != nil {
		return m.TlsIdentity
	}
	return nil
}

func (m *WeightedAddr) GetProtocolHint() *ProtocolHint {
	if m != nil {
		return m.ProtocolHint
	}
	return nil
}

func (m *WeightedAddr) GetAuthorityOverride() string {
	if m != nil {
		return m.AuthorityOverride
	}
	return ""
}

// Which strategy should be used for verifying TLS.
type TlsIdentity struct {
	// Types that are valid to be assigned to Strategy:
	//	*TlsIdentity_DnsLikeIdentity_
	Strategy             isTlsIdentity_Strategy `protobuf_oneof:"strategy"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TlsIdentity) Reset()         { *m = TlsIdentity{} }
func (m *TlsIdentity) String() string { return proto.CompactTextString(m) }
func (*TlsIdentity) ProtoMessage()    {}
func (*TlsIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{5}
}
func (m *TlsIdentity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TlsIdentity.Unmarshal(m, b)
}
func (m *TlsIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TlsIdentity.Marshal(b, m, deterministic)
}
func (dst *TlsIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsIdentity.Merge(dst, src)
}
func (m *TlsIdentity) XXX_Size() int {
	return xxx_messageInfo_TlsIdentity.Size(m)
}
func (m *TlsIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_TlsIdentity proto.InternalMessageInfo

type isTlsIdentity_Strategy interface {
	isTlsIdentity_Strategy()
}

type TlsIdentity_DnsLikeIdentity_ struct {
	DnsLikeIdentity *TlsIdentity_DnsLikeIdentity `protobuf:"bytes,1,opt,name=dns_like_identity,json=dnsLikeIdentity,proto3,oneof"`
}

func (*TlsIdentity_DnsLikeIdentity_) isTlsIdentity_Strategy() {}

func (m *TlsIdentity) GetStrategy() isTlsIdentity_Strategy {
	if m != nil {
		return m.Strategy
	}
	return nil
}

func (m *TlsIdentity) GetDnsLikeIdentity() *TlsIdentity_DnsLikeIdentity {
	if x, ok := m.GetStrategy().(*TlsIdentity_DnsLikeIdentity_); ok {
		return x.DnsLikeIdentity
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TlsIdentity) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TlsIdentity_OneofMarshaler, _TlsIdentity_OneofUnmarshaler, _TlsIdentity_OneofSizer, []interface{}{
		(*TlsIdentity_DnsLikeIdentity_)(nil),
	}
}

func _TlsIdentity_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TlsIdentity)
	// strategy
	switch x := m.Strategy.(type) {
	case *TlsIdentity_DnsLikeIdentity_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsLikeIdentity); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TlsIdentity.Strategy has unexpected type %T", x)
	}
	return nil
}

func _TlsIdentity_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TlsIdentity)
	switch tag {
	case 1: // strategy.dns_like_identity
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsIdentity_DnsLikeIdentity)
		err := b.DecodeMessage(msg)
		m.Strategy = &TlsIdentity_DnsLikeIdentity_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TlsIdentity_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TlsIdentity)
	// strategy
	switch x := m.Strategy.(type) {
	case *TlsIdentity_DnsLikeIdentity_:
		s := proto.Size(x.DnsLikeIdentity)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Verify the certificate based on the Kubernetes pod identity.
type TlsIdentity_DnsLikeIdentity struct {
	// A DNS-like name that encodes workload coordinates.
	//
	// For example:
	//    {name}.{namespace}.{type}.identity.{control-namespace}.{trust-domain...}
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TlsIdentity_DnsLikeIdentity) Reset()         { *m = TlsIdentity_DnsLikeIdentity{} }
func (m *TlsIdentity_DnsLikeIdentity) String() string { return proto.CompactTextString(m) }
func (*TlsIdentity_DnsLikeIdentity) ProtoMessage()    {}
func (*TlsIdentity_DnsLikeIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{5, 0}
}
func (m *TlsIdentity_DnsLikeIdentity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TlsIdentity_DnsLikeIdentity.Unmarshal(m, b)
}
func (m *TlsIdentity_DnsLikeIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TlsIdentity_DnsLikeIdentity.Marshal(b, m, deterministic)
}
func (dst *TlsIdentity_DnsLikeIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsIdentity_DnsLikeIdentity.Merge(dst, src)
}
func (m *TlsIdentity_DnsLikeIdentity) XXX_Size() int {
	return xxx_messageInfo_TlsIdentity_DnsLikeIdentity.Size(m)
}
func (m *TlsIdentity_DnsLikeIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsIdentity_DnsLikeIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_TlsIdentity_DnsLikeIdentity proto.InternalMessageInfo

func (m *TlsIdentity_DnsLikeIdentity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NoEndpoints struct {
	Exists               bool     `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoEndpoints) Reset()         { *m = NoEndpoints{} }
func (m *NoEndpoints) String() string { return proto.CompactTextString(m) }
func (*NoEndpoints) ProtoMessage()    {}
func (*NoEndpoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{6}
}
func (m *NoEndpoints) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoEndpoints.Unmarshal(m, b)
}
func (m *NoEndpoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoEndpoints.Marshal(b, m, deterministic)
}
func (dst *NoEndpoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoEndpoints.Merge(dst, src)
}
func (m *NoEndpoints) XXX_Size() int {
	return xxx_messageInfo_NoEndpoints.Size(m)
}
func (m *NoEndpoints) XXX_DiscardUnknown() {
	xxx_messageInfo_NoEndpoints.DiscardUnknown(m)
}

var xxx_messageInfo_NoEndpoints proto.InternalMessageInfo

func (m *NoEndpoints) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

// A hint of what protocol the service knows. The default value is
// for the `hint` field to be not be set, essentially meaning "unknown".
type ProtocolHint struct {
	// Types that are valid to be assigned to Protocol:
	//	*ProtocolHint_H2_
	Protocol             isProtocolHint_Protocol `protobuf_oneof:"protocol"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ProtocolHint) Reset()         { *m = ProtocolHint{} }
func (m *ProtocolHint) String() string { return proto.CompactTextString(m) }
func (*ProtocolHint) ProtoMessage()    {}
func (*ProtocolHint) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{7}
}
func (m *ProtocolHint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtocolHint.Unmarshal(m, b)
}
func (m *ProtocolHint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtocolHint.Marshal(b, m, deterministic)
}
func (dst *ProtocolHint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolHint.Merge(dst, src)
}
func (m *ProtocolHint) XXX_Size() int {
	return xxx_messageInfo_ProtocolHint.Size(m)
}
func (m *ProtocolHint) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolHint.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolHint proto.InternalMessageInfo

type isProtocolHint_Protocol interface {
	isProtocolHint_Protocol()
}

type ProtocolHint_H2_ struct {
	H2 *ProtocolHint_H2 `protobuf:"bytes,1,opt,name=h2,proto3,oneof"`
}

func (*ProtocolHint_H2_) isProtocolHint_Protocol() {}

func (m *ProtocolHint) GetProtocol() isProtocolHint_Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *ProtocolHint) GetH2() *ProtocolHint_H2 {
	if x, ok := m.GetProtocol().(*ProtocolHint_H2_); ok {
		return x.H2
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProtocolHint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProtocolHint_OneofMarshaler, _ProtocolHint_OneofUnmarshaler, _ProtocolHint_OneofSizer, []interface{}{
		(*ProtocolHint_H2_)(nil),
	}
}

func _ProtocolHint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProtocolHint)
	// protocol
	switch x := m.Protocol.(type) {
	case *ProtocolHint_H2_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.H2); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProtocolHint.Protocol has unexpected type %T", x)
	}
	return nil
}

func _ProtocolHint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProtocolHint)
	switch tag {
	case 1: // protocol.h2
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProtocolHint_H2)
		err := b.DecodeMessage(msg)
		m.Protocol = &ProtocolHint_H2_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProtocolHint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProtocolHint)
	// protocol
	switch x := m.Protocol.(type) {
	case *ProtocolHint_H2_:
		s := proto.Size(x.H2)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ProtocolHint_H2 struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtocolHint_H2) Reset()         { *m = ProtocolHint_H2{} }
func (m *ProtocolHint_H2) String() string { return proto.CompactTextString(m) }
func (*ProtocolHint_H2) ProtoMessage()    {}
func (*ProtocolHint_H2) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{7, 0}
}
func (m *ProtocolHint_H2) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtocolHint_H2.Unmarshal(m, b)
}
func (m *ProtocolHint_H2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtocolHint_H2.Marshal(b, m, deterministic)
}
func (dst *ProtocolHint_H2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolHint_H2.Merge(dst, src)
}
func (m *ProtocolHint_H2) XXX_Size() int {
	return xxx_messageInfo_ProtocolHint_H2.Size(m)
}
func (m *ProtocolHint_H2) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolHint_H2.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolHint_H2 proto.InternalMessageInfo

type DestinationProfile struct {
	// A list of routes, each with a RequestMatch.  If a request matches
	// more than one route, the first match wins.
	Routes []*Route `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// The retry budget controls how much additional load the proxy can generate
	// as retries.  Failured requests on retryable routes will not be retried if
	// there is no available budget.
	RetryBudget *RetryBudget `protobuf:"bytes,2,opt,name=retry_budget,json=retryBudget,proto3" json:"retry_budget,omitempty"`
	// If this list is non-empty, requests to this destination should instead be
	// split between the destinations in this list.  Each destination should
	// receive a portion of the requests proportional to its weight.  If this list
	// is empty, requests should be sent to this destination as normal.
	DstOverrides         []*WeightedDst `protobuf:"bytes,3,rep,name=dst_overrides,json=dstOverrides,proto3" json:"dst_overrides,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DestinationProfile) Reset()         { *m = DestinationProfile{} }
func (m *DestinationProfile) String() string { return proto.CompactTextString(m) }
func (*DestinationProfile) ProtoMessage()    {}
func (*DestinationProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{8}
}
func (m *DestinationProfile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DestinationProfile.Unmarshal(m, b)
}
func (m *DestinationProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DestinationProfile.Marshal(b, m, deterministic)
}
func (dst *DestinationProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestinationProfile.Merge(dst, src)
}
func (m *DestinationProfile) XXX_Size() int {
	return xxx_messageInfo_DestinationProfile.Size(m)
}
func (m *DestinationProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_DestinationProfile.DiscardUnknown(m)
}

var xxx_messageInfo_DestinationProfile proto.InternalMessageInfo

func (m *DestinationProfile) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *DestinationProfile) GetRetryBudget() *RetryBudget {
	if m != nil {
		return m.RetryBudget
	}
	return nil
}

func (m *DestinationProfile) GetDstOverrides() []*WeightedDst {
	if m != nil {
		return m.DstOverrides
	}
	return nil
}

type Route struct {
	// This route contains requests which match this condition.
	Condition *RequestMatch `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	// A list of response classes for this route.  If a response matches
	// more than one ResponseClass, the first match wins.  If a response does not
	// match any ResponseClasses, it is considered to be a successful response.
	ResponseClasses []*ResponseClass `protobuf:"bytes,2,rep,name=response_classes,json=responseClasses,proto3" json:"response_classes,omitempty"`
	// Metric labels to attach to requests and responses that match this route.
	MetricsLabels map[string]string `protobuf:"bytes,3,rep,name=metrics_labels,json=metricsLabels,proto3" json:"metrics_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If a route is retryable, any failed requests on that route may be retried
	// by the proxy.
	IsRetryable bool `protobuf:"varint,4,opt,name=is_retryable,json=isRetryable,proto3" json:"is_retryable,omitempty"`
	// After this time has elapsed since receiving the initial request, any
	// outstanding request will be cancelled, a timeout error response will be
	// returned, and no more retries will be attempted.
	Timeout              *duration.Duration `protobuf:"bytes,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{9}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Route.Unmarshal(m, b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Route.Marshal(b, m, deterministic)
}
func (dst *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(dst, src)
}
func (m *Route) XXX_Size() int {
	return xxx_messageInfo_Route.Size(m)
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetCondition() *RequestMatch {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *Route) GetResponseClasses() []*ResponseClass {
	if m != nil {
		return m.ResponseClasses
	}
	return nil
}

func (m *Route) GetMetricsLabels() map[string]string {
	if m != nil {
		return m.MetricsLabels
	}
	return nil
}

func (m *Route) GetIsRetryable() bool {
	if m != nil {
		return m.IsRetryable
	}
	return false
}

func (m *Route) GetTimeout() *duration.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

type RetryBudget struct {
	// The ratio of additional traffic that may be added by retries.  A
	// retry_ratio of 0.1 means that 1 retry may be attempted for every 10 regular
	// requests.  A retry_ratio of 1.0 means that 1 retry may be attempted for
	// every 1 regular request (in other words, total request load may be doubled
	// as a result of retries).
	RetryRatio float32 `protobuf:"fixed32,1,opt,name=retry_ratio,json=retryRatio,proto3" json:"retry_ratio,omitempty"`
	// The proxy may always attempt this number of retries per second, even if it
	// would violate the retry_ratio.  This is to allow retries to happen even
	// when the request rate is very low.
	MinRetriesPerSecond uint32 `protobuf:"varint,2,opt,name=min_retries_per_second,json=minRetriesPerSecond,proto3" json:"min_retries_per_second,omitempty"`
	// This duration indicates for how long requests should be considered for the
	// purposes of enforcing the retry_ratio.  A higher value considers a larger
	// window and therefore allows burstier retries.
	Ttl                  *duration.Duration `protobuf:"bytes,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RetryBudget) Reset()         { *m = RetryBudget{} }
func (m *RetryBudget) String() string { return proto.CompactTextString(m) }
func (*RetryBudget) ProtoMessage()    {}
func (*RetryBudget) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{10}
}
func (m *RetryBudget) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RetryBudget.Unmarshal(m, b)
}
func (m *RetryBudget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RetryBudget.Marshal(b, m, deterministic)
}
func (dst *RetryBudget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryBudget.Merge(dst, src)
}
func (m *RetryBudget) XXX_Size() int {
	return xxx_messageInfo_RetryBudget.Size(m)
}
func (m *RetryBudget) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryBudget.DiscardUnknown(m)
}

var xxx_messageInfo_RetryBudget proto.InternalMessageInfo

func (m *RetryBudget) GetRetryRatio() float32 {
	if m != nil {
		return m.RetryRatio
	}
	return 0
}

func (m *RetryBudget) GetMinRetriesPerSecond() uint32 {
	if m != nil {
		return m.MinRetriesPerSecond
	}
	return 0
}

func (m *RetryBudget) GetTtl() *duration.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

type ResponseClass struct {
	// This class contains responses which match this condition.
	Condition *ResponseMatch `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	// If responses in this class should be considered failures.  This defaults
	// to false (success).
	IsFailure            bool     `protobuf:"varint,2,opt,name=is_failure,json=isFailure,proto3" json:"is_failure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseClass) Reset()         { *m = ResponseClass{} }
func (m *ResponseClass) String() string { return proto.CompactTextString(m) }
func (*ResponseClass) ProtoMessage()    {}
func (*ResponseClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{11}
}
func (m *ResponseClass) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseClass.Unmarshal(m, b)
}
func (m *ResponseClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseClass.Marshal(b, m, deterministic)
}
func (dst *ResponseClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseClass.Merge(dst, src)
}
func (m *ResponseClass) XXX_Size() int {
	return xxx_messageInfo_ResponseClass.Size(m)
}
func (m *ResponseClass) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseClass.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseClass proto.InternalMessageInfo

func (m *ResponseClass) GetCondition() *ResponseMatch {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *ResponseClass) GetIsFailure() bool {
	if m != nil {
		return m.IsFailure
	}
	return false
}

type RequestMatch struct {
	// Types that are valid to be assigned to Match:
	//	*RequestMatch_All
	//	*RequestMatch_Any
	//	*RequestMatch_Not
	//	*RequestMatch_Path
	//	*RequestMatch_Method
	Match                isRequestMatch_Match `protobuf_oneof:"match"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RequestMatch) Reset()         { *m = RequestMatch{} }
func (m *RequestMatch) String() string { return proto.CompactTextString(m) }
func (*RequestMatch) ProtoMessage()    {}
func (*RequestMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{12}
}
func (m *RequestMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestMatch.Unmarshal(m, b)
}
func (m *RequestMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestMatch.Marshal(b, m, deterministic)
}
func (dst *RequestMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMatch.Merge(dst, src)
}
func (m *RequestMatch) XXX_Size() int {
	return xxx_messageInfo_RequestMatch.Size(m)
}
func (m *RequestMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMatch proto.InternalMessageInfo

type isRequestMatch_Match interface {
	isRequestMatch_Match()
}

type RequestMatch_All struct {
	All *RequestMatch_Seq `protobuf:"bytes,1,opt,name=all,proto3,oneof"`
}

type RequestMatch_Any struct {
	Any *RequestMatch_Seq `protobuf:"bytes,2,opt,name=any,proto3,oneof"`
}

type RequestMatch_Not struct {
	Not *RequestMatch `protobuf:"bytes,3,opt,name=not,proto3,oneof"`
}

type RequestMatch_Path struct {
	Path *PathMatch `protobuf:"bytes,4,opt,name=path,proto3,oneof"`
}

type RequestMatch_Method struct {
	Method *http_types.HttpMethod `protobuf:"bytes,5,opt,name=method,proto3,oneof"`
}

func (*RequestMatch_All) isRequestMatch_Match() {}

func (*RequestMatch_Any) isRequestMatch_Match() {}

func (*RequestMatch_Not) isRequestMatch_Match() {}

func (*RequestMatch_Path) isRequestMatch_Match() {}

func (*RequestMatch_Method) isRequestMatch_Match() {}

func (m *RequestMatch) GetMatch() isRequestMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RequestMatch) GetAll() *RequestMatch_Seq {
	if x, ok := m.GetMatch().(*RequestMatch_All); ok {
		return x.All
	}
	return nil
}

func (m *RequestMatch) GetAny() *RequestMatch_Seq {
	if x, ok := m.GetMatch().(*RequestMatch_Any); ok {
		return x.Any
	}
	return nil
}

func (m *RequestMatch) GetNot() *RequestMatch {
	if x, ok := m.GetMatch().(*RequestMatch_Not); ok {
		return x.Not
	}
	return nil
}

func (m *RequestMatch) GetPath() *PathMatch {
	if x, ok := m.GetMatch().(*RequestMatch_Path); ok {
		return x.Path
	}
	return nil
}

func (m *RequestMatch) GetMethod() *http_types.HttpMethod {
	if x, ok := m.GetMatch().(*RequestMatch_Method); ok {
		return x.Method
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RequestMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RequestMatch_OneofMarshaler, _RequestMatch_OneofUnmarshaler, _RequestMatch_OneofSizer, []interface{}{
		(*RequestMatch_All)(nil),
		(*RequestMatch_Any)(nil),
		(*RequestMatch_Not)(nil),
		(*RequestMatch_Path)(nil),
		(*RequestMatch_Method)(nil),
	}
}

func _RequestMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RequestMatch)
	// match
	switch x := m.Match.(type) {
	case *RequestMatch_All:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *RequestMatch_Any:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *RequestMatch_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *RequestMatch_Path:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Path); err != nil {
			return err
		}
	case *RequestMatch_Method:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Method); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RequestMatch.Match has unexpected type %T", x)
	}
	return nil
}

func _RequestMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RequestMatch)
	switch tag {
	case 1: // match.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_All{msg}
		return true, err
	case 2: // match.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Any{msg}
		return true, err
	case 3: // match.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatch)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Not{msg}
		return true, err
	case 4: // match.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PathMatch)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Path{msg}
		return true, err
	case 5: // match.method
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(http_types.HttpMethod)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Method{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RequestMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RequestMatch)
	// match
	switch x := m.Match.(type) {
	case *RequestMatch_All:
		s := proto.Size(x.All)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Any:
		s := proto.Size(x.Any)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Not:
		s := proto.Size(x.Not)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Path:
		s := proto.Size(x.Path)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Method:
		s := proto.Size(x.Method)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RequestMatch_Seq struct {
	Matches              []*RequestMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RequestMatch_Seq) Reset()         { *m = RequestMatch_Seq{} }
func (m *RequestMatch_Seq) String() string { return proto.CompactTextString(m) }
func (*RequestMatch_Seq) ProtoMessage()    {}
func (*RequestMatch_Seq) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{12, 0}
}
func (m *RequestMatch_Seq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestMatch_Seq.Unmarshal(m, b)
}
func (m *RequestMatch_Seq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestMatch_Seq.Marshal(b, m, deterministic)
}
func (dst *RequestMatch_Seq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMatch_Seq.Merge(dst, src)
}
func (m *RequestMatch_Seq) XXX_Size() int {
	return xxx_messageInfo_RequestMatch_Seq.Size(m)
}
func (m *RequestMatch_Seq) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMatch_Seq.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMatch_Seq proto.InternalMessageInfo

func (m *RequestMatch_Seq) GetMatches() []*RequestMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

type PathMatch struct {
	// Match if the request path matches this regex.
	Regex                string   `protobuf:"bytes,1,opt,name=regex,proto3" json:"regex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathMatch) Reset()         { *m = PathMatch{} }
func (m *PathMatch) String() string { return proto.CompactTextString(m) }
func (*PathMatch) ProtoMessage()    {}
func (*PathMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{13}
}
func (m *PathMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PathMatch.Unmarshal(m, b)
}
func (m *PathMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PathMatch.Marshal(b, m, deterministic)
}
func (dst *PathMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathMatch.Merge(dst, src)
}
func (m *PathMatch) XXX_Size() int {
	return xxx_messageInfo_PathMatch.Size(m)
}
func (m *PathMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PathMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PathMatch proto.InternalMessageInfo

func (m *PathMatch) GetRegex() string {
	if m != nil {
		return m.Regex
	}
	return ""
}

type ResponseMatch struct {
	// Types that are valid to be assigned to Match:
	//	*ResponseMatch_All
	//	*ResponseMatch_Any
	//	*ResponseMatch_Not
	//	*ResponseMatch_Status
	Match                isResponseMatch_Match `protobuf_oneof:"match"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ResponseMatch) Reset()         { *m = ResponseMatch{} }
func (m *ResponseMatch) String() string { return proto.CompactTextString(m) }
func (*ResponseMatch) ProtoMessage()    {}
func (*ResponseMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{14}
}
func (m *ResponseMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseMatch.Unmarshal(m, b)
}
func (m *ResponseMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseMatch.Marshal(b, m, deterministic)
}
func (dst *ResponseMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMatch.Merge(dst, src)
}
func (m *ResponseMatch) XXX_Size() int {
	return xxx_messageInfo_ResponseMatch.Size(m)
}
func (m *ResponseMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMatch proto.InternalMessageInfo

type isResponseMatch_Match interface {
	isResponseMatch_Match()
}

type ResponseMatch_All struct {
	All *ResponseMatch_Seq `protobuf:"bytes,1,opt,name=all,proto3,oneof"`
}

type ResponseMatch_Any struct {
	Any *ResponseMatch_Seq `protobuf:"bytes,2,opt,name=any,proto3,oneof"`
}

type ResponseMatch_Not struct {
	Not *ResponseMatch `protobuf:"bytes,3,opt,name=not,proto3,oneof"`
}

type ResponseMatch_Status struct {
	Status *HttpStatusRange `protobuf:"bytes,4,opt,name=status,proto3,oneof"`
}

func (*ResponseMatch_All) isResponseMatch_Match() {}

func (*ResponseMatch_Any) isResponseMatch_Match() {}

func (*ResponseMatch_Not) isResponseMatch_Match() {}

func (*ResponseMatch_Status) isResponseMatch_Match() {}

func (m *ResponseMatch) GetMatch() isResponseMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ResponseMatch) GetAll() *ResponseMatch_Seq {
	if x, ok := m.GetMatch().(*ResponseMatch_All); ok {
		return x.All
	}
	return nil
}

func (m *ResponseMatch) GetAny() *ResponseMatch_Seq {
	if x, ok := m.GetMatch().(*ResponseMatch_Any); ok {
		return x.Any
	}
	return nil
}

func (m *ResponseMatch) GetNot() *ResponseMatch {
	if x, ok := m.GetMatch().(*ResponseMatch_Not); ok {
		return x.Not
	}
	return nil
}

func (m *ResponseMatch) GetStatus() *HttpStatusRange {
	if x, ok := m.GetMatch().(*ResponseMatch_Status); ok {
		return x.Status
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResponseMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResponseMatch_OneofMarshaler, _ResponseMatch_OneofUnmarshaler, _ResponseMatch_OneofSizer, []interface{}{
		(*ResponseMatch_All)(nil),
		(*ResponseMatch_Any)(nil),
		(*ResponseMatch_Not)(nil),
		(*ResponseMatch_Status)(nil),
	}
}

func _ResponseMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResponseMatch)
	// match
	switch x := m.Match.(type) {
	case *ResponseMatch_All:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *ResponseMatch_Any:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *ResponseMatch_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *ResponseMatch_Status:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Status); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResponseMatch.Match has unexpected type %T", x)
	}
	return nil
}

func _ResponseMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResponseMatch)
	switch tag {
	case 1: // match.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_All{msg}
		return true, err
	case 2: // match.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_Any{msg}
		return true, err
	case 3: // match.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseMatch)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_Not{msg}
		return true, err
	case 4: // match.status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpStatusRange)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_Status{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResponseMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResponseMatch)
	// match
	switch x := m.Match.(type) {
	case *ResponseMatch_All:
		s := proto.Size(x.All)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseMatch_Any:
		s := proto.Size(x.Any)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseMatch_Not:
		s := proto.Size(x.Not)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseMatch_Status:
		s := proto.Size(x.Status)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ResponseMatch_Seq struct {
	Matches              []*ResponseMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ResponseMatch_Seq) Reset()         { *m = ResponseMatch_Seq{} }
func (m *ResponseMatch_Seq) String() string { return proto.CompactTextString(m) }
func (*ResponseMatch_Seq) ProtoMessage()    {}
func (*ResponseMatch_Seq) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{14, 0}
}
func (m *ResponseMatch_Seq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseMatch_Seq.Unmarshal(m, b)
}
func (m *ResponseMatch_Seq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseMatch_Seq.Marshal(b, m, deterministic)
}
func (dst *ResponseMatch_Seq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMatch_Seq.Merge(dst, src)
}
func (m *ResponseMatch_Seq) XXX_Size() int {
	return xxx_messageInfo_ResponseMatch_Seq.Size(m)
}
func (m *ResponseMatch_Seq) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMatch_Seq.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMatch_Seq proto.InternalMessageInfo

func (m *ResponseMatch_Seq) GetMatches() []*ResponseMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

// If either a minimum or maximum is not specified, the range is considered to be
// over a discrete value.
type HttpStatusRange struct {
	// Minimum matching http status code (inclusive), if specified.
	Min uint32 `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	// Maximum matching http status code (inclusive), if specified.
	Max                  uint32   `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpStatusRange) Reset()         { *m = HttpStatusRange{} }
func (m *HttpStatusRange) String() string { return proto.CompactTextString(m) }
func (*HttpStatusRange) ProtoMessage()    {}
func (*HttpStatusRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{15}
}
func (m *HttpStatusRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HttpStatusRange.Unmarshal(m, b)
}
func (m *HttpStatusRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HttpStatusRange.Marshal(b, m, deterministic)
}
func (dst *HttpStatusRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpStatusRange.Merge(dst, src)
}
func (m *HttpStatusRange) XXX_Size() int {
	return xxx_messageInfo_HttpStatusRange.Size(m)
}
func (m *HttpStatusRange) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpStatusRange.DiscardUnknown(m)
}

var xxx_messageInfo_HttpStatusRange proto.InternalMessageInfo

func (m *HttpStatusRange) GetMin() uint32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *HttpStatusRange) GetMax() uint32 {
	if m != nil {
		return m.Max
	}
	return 0
}

type WeightedDst struct {
	// This authority will be used as the `path` in a call to the Destination.Get
	// rpc.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// The proportion of requests to send to this destination.  This value is
	// relative to other weights in the same dst_overrides list.
	Weight               uint32   `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeightedDst) Reset()         { *m = WeightedDst{} }
func (m *WeightedDst) String() string { return proto.CompactTextString(m) }
func (*WeightedDst) ProtoMessage()    {}
func (*WeightedDst) Descriptor() ([]byte, []int) {
	return fileDescriptor_destination_e9613e74e66f1868, []int{16}
}
func (m *WeightedDst) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WeightedDst.Unmarshal(m, b)
}
func (m *WeightedDst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WeightedDst.Marshal(b, m, deterministic)
}
func (dst *WeightedDst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedDst.Merge(dst, src)
}
func (m *WeightedDst) XXX_Size() int {
	return xxx_messageInfo_WeightedDst.Size(m)
}
func (m *WeightedDst) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedDst.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedDst proto.InternalMessageInfo

func (m *WeightedDst) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *WeightedDst) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func init() {
	proto.RegisterType((*GetDestination)(nil), "io.linkerd.proxy.destination.GetDestination")
	proto.RegisterType((*Update)(nil), "io.linkerd.proxy.destination.Update")
	proto.RegisterType((*AddrSet)(nil), "io.linkerd.proxy.destination.AddrSet")
	proto.RegisterType((*WeightedAddrSet)(nil), "io.linkerd.proxy.destination.WeightedAddrSet")
	proto.RegisterMapType((map[string]string)(nil), "io.linkerd.proxy.destination.WeightedAddrSet.MetricLabelsEntry")
	proto.RegisterType((*WeightedAddr)(nil), "io.linkerd.proxy.destination.WeightedAddr")
	proto.RegisterMapType((map[string]string)(nil), "io.linkerd.proxy.destination.WeightedAddr.MetricLabelsEntry")
	proto.RegisterType((*TlsIdentity)(nil), "io.linkerd.proxy.destination.TlsIdentity")
	proto.RegisterType((*TlsIdentity_DnsLikeIdentity)(nil), "io.linkerd.proxy.destination.TlsIdentity.DnsLikeIdentity")
	proto.RegisterType((*NoEndpoints)(nil), "io.linkerd.proxy.destination.NoEndpoints")
	proto.RegisterType((*ProtocolHint)(nil), "io.linkerd.proxy.destination.ProtocolHint")
	proto.RegisterType((*ProtocolHint_H2)(nil), "io.linkerd.proxy.destination.ProtocolHint.H2")
	proto.RegisterType((*DestinationProfile)(nil), "io.linkerd.proxy.destination.DestinationProfile")
	proto.RegisterType((*Route)(nil), "io.linkerd.proxy.destination.Route")
	proto.RegisterMapType((map[string]string)(nil), "io.linkerd.proxy.destination.Route.MetricsLabelsEntry")
	proto.RegisterType((*RetryBudget)(nil), "io.linkerd.proxy.destination.RetryBudget")
	proto.RegisterType((*ResponseClass)(nil), "io.linkerd.proxy.destination.ResponseClass")
	proto.RegisterType((*RequestMatch)(nil), "io.linkerd.proxy.destination.RequestMatch")
	proto.RegisterType((*RequestMatch_Seq)(nil), "io.linkerd.proxy.destination.RequestMatch.Seq")
	proto.RegisterType((*PathMatch)(nil), "io.linkerd.proxy.destination.PathMatch")
	proto.RegisterType((*ResponseMatch)(nil), "io.linkerd.proxy.destination.ResponseMatch")
	proto.RegisterType((*ResponseMatch_Seq)(nil), "io.linkerd.proxy.destination.ResponseMatch.Seq")
	proto.RegisterType((*HttpStatusRange)(nil), "io.linkerd.proxy.destination.HttpStatusRange")
	proto.RegisterType((*WeightedDst)(nil), "io.linkerd.proxy.destination.WeightedDst")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DestinationClient is the client API for Destination service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DestinationClient interface {
	// Given a destination, return all addresses in that destination as a long-
	// running stream of updates.
	Get(ctx context.Context, in *GetDestination, opts ...grpc.CallOption) (Destination_GetClient, error)
	// Given a destination, return that destination's profile and send an update
	// whenever it changes.
	GetProfile(ctx context.Context, in *GetDestination, opts ...grpc.CallOption) (Destination_GetProfileClient, error)
}

type destinationClient struct {
	cc *grpc.ClientConn
}

func NewDestinationClient(cc *grpc.ClientConn) DestinationClient {
	return &destinationClient{cc}
}

func (c *destinationClient) Get(ctx context.Context, in *GetDestination, opts ...grpc.CallOption) (Destination_GetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Destination_serviceDesc.Streams[0], "/io.linkerd.proxy.destination.Destination/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &destinationGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Destination_GetClient interface {
	Recv() (*Update, error)
	grpc.ClientStream
}

type destinationGetClient struct {
	grpc.ClientStream
}

func (x *destinationGetClient) Recv() (*Update, error) {
	m := new(Update)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *destinationClient) GetProfile(ctx context.Context, in *GetDestination, opts ...grpc.CallOption) (Destination_GetProfileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Destination_serviceDesc.Streams[1], "/io.linkerd.proxy.destination.Destination/GetProfile", opts...)
	if err != nil {
		return nil, err
	}
	x := &destinationGetProfileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Destination_GetProfileClient interface {
	Recv() (*DestinationProfile, error)
	grpc.ClientStream
}

type destinationGetProfileClient struct {
	grpc.ClientStream
}

func (x *destinationGetProfileClient) Recv() (*DestinationProfile, error) {
	m := new(DestinationProfile)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DestinationServer is the server API for Destination service.
type DestinationServer interface {
	// Given a destination, return all addresses in that destination as a long-
	// running stream of updates.
	Get(*GetDestination, Destination_GetServer) error
	// Given a destination, return that destination's profile and send an update
	// whenever it changes.
	GetProfile(*GetDestination, Destination_GetProfileServer) error
}

func RegisterDestinationServer(s *grpc.Server, srv DestinationServer) {
	s.RegisterService(&_Destination_serviceDesc, srv)
}

func _Destination_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDestination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DestinationServer).Get(m, &destinationGetServer{stream})
}

type Destination_GetServer interface {
	Send(*Update) error
	grpc.ServerStream
}

type destinationGetServer struct {
	grpc.ServerStream
}

func (x *destinationGetServer) Send(m *Update) error {
	return x.ServerStream.SendMsg(m)
}

func _Destination_GetProfile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDestination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DestinationServer).GetProfile(m, &destinationGetProfileServer{stream})
}

type Destination_GetProfileServer interface {
	Send(*DestinationProfile) error
	grpc.ServerStream
}

type destinationGetProfileServer struct {
	grpc.ServerStream
}

func (x *destinationGetProfileServer) Send(m *DestinationProfile) error {
	return x.ServerStream.SendMsg(m)
}

var _Destination_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.linkerd.proxy.destination.Destination",
	HandlerType: (*DestinationServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Get",
			Handler:       _Destination_Get_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProfile",
			Handler:       _Destination_GetProfile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "destination.proto",
}

func init() { proto.RegisterFile("destination.proto", fileDescriptor_destination_e9613e74e66f1868) }

var fileDescriptor_destination_e9613e74e66f1868 = []byte{
	// 1288 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x72, 0x1b, 0x35,
	0x14, 0x8e, 0xbd, 0x8e, 0x93, 0x9c, 0xb5, 0x9b, 0x44, 0x30, 0x1d, 0xe3, 0x29, 0xd0, 0x6e, 0xe9,
	0x50, 0x5a, 0xb2, 0xe9, 0xb8, 0xa5, 0x53, 0x7e, 0xd3, 0xfc, 0x94, 0xb8, 0x90, 0xfe, 0x8c, 0x52,
	0x60, 0x86, 0x99, 0xce, 0xce, 0xc6, 0x7b, 0x6a, 0x6b, 0xb2, 0x96, 0xb6, 0x2b, 0x39, 0xc4, 0x6f,
	0xc1, 0x33, 0xf0, 0x00, 0xbc, 0x03, 0x2f, 0xc0, 0x23, 0x70, 0xc9, 0x2d, 0xf7, 0xbd, 0x62, 0xa4,
	0xd5, 0xc6, 0x9b, 0x98, 0xf1, 0x4f, 0xb9, 0xb2, 0x74, 0x74, 0xce, 0x27, 0xe9, 0x7c, 0x9f, 0xce,
	0x1e, 0xc3, 0x7a, 0x84, 0x52, 0x31, 0x1e, 0x2a, 0x26, 0xb8, 0x9f, 0xa4, 0x42, 0x09, 0x72, 0x85,
	0x09, 0x3f, 0x66, 0xfc, 0x18, 0xd3, 0x48, 0x5b, 0x4e, 0x87, 0x7e, 0xc1, 0xa7, 0xf9, 0x41, 0x57,
	0x88, 0x6e, 0x8c, 0x9b, 0xc6, 0xf7, 0x68, 0xf0, 0x6a, 0x33, 0x1a, 0xa4, 0x85, 0xe8, 0xe6, 0x5a,
	0x4f, 0xa9, 0x24, 0x50, 0xc3, 0x04, 0xa5, 0xb5, 0xac, 0x70, 0x54, 0xd9, 0xd0, 0x0b, 0xe1, 0xd2,
	0x3e, 0xaa, 0xbd, 0x11, 0x1c, 0xb9, 0x0c, 0x55, 0xd9, 0xe9, 0x61, 0x1f, 0x1b, 0xa5, 0xab, 0xa5,
	0x9b, 0x2b, 0xd4, 0xce, 0x08, 0x81, 0x4a, 0x12, 0xaa, 0x5e, 0xa3, 0x6c, 0xac, 0x66, 0x4c, 0xae,
	0x43, 0xbd, 0x23, 0xb8, 0xc2, 0x53, 0x15, 0x28, 0x71, 0x8c, 0xbc, 0xe1, 0x98, 0xc5, 0x9a, 0x35,
	0xbe, 0xd0, 0x36, 0xef, 0xef, 0x12, 0x54, 0x7f, 0x48, 0xa2, 0x50, 0x21, 0xd9, 0x06, 0x27, 0x8c,
	0x22, 0x03, 0xec, 0xb6, 0x36, 0xfc, 0x49, 0xd7, 0xf2, 0x7f, 0x42, 0xd6, 0xed, 0x29, 0x8c, 0xb6,
	0xa3, 0x28, 0x3d, 0x44, 0xd5, 0x5e, 0xa0, 0x3a, 0x96, 0x6c, 0x41, 0x35, 0xc5, 0xbe, 0x38, 0x41,
	0x73, 0x10, 0xb7, 0x75, 0x63, 0x32, 0xca, 0x28, 0xda, 0x86, 0x91, 0xa7, 0x50, 0xe3, 0x22, 0x40,
	0x1e, 0x25, 0x82, 0x71, 0x25, 0xcd, 0x91, 0xdd, 0xd6, 0x27, 0x93, 0x61, 0x9e, 0x8a, 0x47, 0x79,
	0x40, 0x7b, 0x81, 0xba, 0x7c, 0x34, 0xdd, 0x59, 0x86, 0xea, 0xc0, 0xdc, 0xce, 0xdb, 0x86, 0x25,
	0xbb, 0x1d, 0xb9, 0x0f, 0x8b, 0x61, 0x14, 0xa5, 0xb2, 0x51, 0xba, 0xea, 0xdc, 0x74, 0x5b, 0x57,
	0xc7, 0xd1, 0x35, 0x05, 0x2f, 0x3a, 0x89, 0x0e, 0x40, 0x29, 0x69, 0xe6, 0xee, 0xbd, 0x29, 0xc1,
	0xea, 0x85, 0x8b, 0x93, 0x87, 0xe7, 0xb1, 0x6e, 0xcd, 0x9e, 0x36, 0x8b, 0x4a, 0x22, 0xa8, 0xf7,
	0x51, 0xa5, 0xac, 0x13, 0xc4, 0xe1, 0x11, 0xc6, 0xb2, 0x51, 0x36, 0x48, 0x5b, 0x73, 0x11, 0xe0,
	0x3f, 0x31, 0x10, 0x07, 0x06, 0xe1, 0x11, 0x57, 0xe9, 0x90, 0xd6, 0xfa, 0x05, 0x53, 0x73, 0x0b,
	0xd6, 0xc7, 0x5c, 0xc8, 0x1a, 0x38, 0xc7, 0x38, 0xb4, 0x52, 0xd2, 0x43, 0xf2, 0x2e, 0x2c, 0x9e,
	0x84, 0xf1, 0x00, 0xad, 0x90, 0xb2, 0xc9, 0x17, 0xe5, 0x07, 0x25, 0xef, 0x4f, 0x07, 0x6a, 0xc5,
	0x4d, 0xc9, 0x3d, 0xa8, 0xe8, 0x0b, 0x58, 0xbd, 0x4c, 0x4f, 0xa2, 0xf1, 0xd6, 0x02, 0xfe, 0xc5,
	0xa0, 0x18, 0x6a, 0xeb, 0xd4, 0xce, 0x48, 0x78, 0x31, 0x0b, 0x15, 0x93, 0x85, 0xaf, 0x66, 0xcf,
	0xc2, 0xb4, 0x14, 0x90, 0x03, 0xa8, 0xa9, 0x58, 0x06, 0x2c, 0x42, 0xae, 0x98, 0x1a, 0x36, 0x16,
	0x67, 0xd1, 0xd6, 0x8b, 0x58, 0x3e, 0xb6, 0x01, 0xd4, 0x55, 0xa3, 0x09, 0x79, 0x06, 0x75, 0xf3,
	0x48, 0x3b, 0x22, 0x0e, 0x7a, 0x8c, 0xab, 0x46, 0xd5, 0xc0, 0x4d, 0x11, 0xc0, 0x73, 0x1b, 0xd2,
	0x66, 0x5c, 0xd1, 0x5a, 0x52, 0x98, 0x91, 0x0d, 0x20, 0xe1, 0x40, 0xf5, 0x44, 0xca, 0xd4, 0x30,
	0x10, 0x27, 0x98, 0xa6, 0x2c, 0xc2, 0xc6, 0x92, 0xe1, 0x61, 0xfd, 0x6c, 0xe5, 0x99, 0x5d, 0xf8,
	0xff, 0x84, 0xfe, 0x51, 0x02, 0xb7, 0x70, 0x3b, 0xd2, 0x85, 0xf5, 0x88, 0xcb, 0x20, 0x66, 0xc7,
	0x38, 0xca, 0x51, 0x46, 0xee, 0xe7, 0x33, 0xe7, 0xc8, 0xdf, 0xe3, 0xf2, 0x80, 0x1d, 0x63, 0x3e,
	0x6f, 0x2f, 0xd0, 0xd5, 0xe8, 0xbc, 0xa9, 0x79, 0x03, 0x56, 0x2f, 0x78, 0xe9, 0xf2, 0xc5, 0xc3,
	0xb3, 0xa2, 0x66, 0xc6, 0x3b, 0x00, 0xcb, 0x52, 0xa5, 0xa1, 0xc2, 0xee, 0xf0, 0xbb, 0xca, 0x72,
	0x79, 0xcd, 0xa1, 0x6b, 0xc7, 0x0f, 0x64, 0x90, 0x88, 0xe8, 0xec, 0x78, 0xde, 0x0d, 0x70, 0x0b,
	0x8f, 0x5f, 0x8b, 0x0b, 0x4f, 0x99, 0x54, 0xd2, 0x00, 0x2d, 0x53, 0x3b, 0xf3, 0x42, 0xa8, 0x15,
	0x13, 0x4f, 0xb6, 0xa0, 0xdc, 0x6b, 0xcd, 0x56, 0xe8, 0x8a, 0x71, 0x7e, 0xbb, 0xd5, 0x5e, 0xa0,
	0xe5, 0x5e, 0xab, 0x59, 0x81, 0x72, 0xbb, 0xa5, 0x4f, 0x98, 0x33, 0xe8, 0xfd, 0x53, 0x02, 0x52,
	0x28, 0xd4, 0xcf, 0x53, 0xf1, 0x8a, 0xc5, 0x48, 0xbe, 0x84, 0x6a, 0x2a, 0x06, 0x0a, 0xf3, 0xfa,
	0x70, 0x7d, 0xf2, 0x6e, 0x54, 0xfb, 0x52, 0x1b, 0xa2, 0x05, 0x9b, 0xa2, 0x4a, 0x87, 0xc1, 0xd1,
	0x20, 0xea, 0xa2, 0xb2, 0x35, 0x75, 0x8a, 0x60, 0xa9, 0x8e, 0xd8, 0x31, 0x01, 0xd4, 0x4d, 0x47,
	0x13, 0xf2, 0x14, 0xea, 0x91, 0x54, 0x67, 0xca, 0xd2, 0xb5, 0xd5, 0x99, 0x0e, 0x97, 0xbf, 0xb0,
	0x3d, 0xa9, 0x68, 0x2d, 0x92, 0x2a, 0xd7, 0x9f, 0xf4, 0x7e, 0x73, 0x60, 0xd1, 0x9c, 0x97, 0xb4,
	0x61, 0xa5, 0x23, 0x78, 0xc4, 0x74, 0x80, 0xcd, 0xea, 0xad, 0x69, 0x87, 0x7c, 0x3d, 0x40, 0xa9,
	0x9e, 0x84, 0xaa, 0xd3, 0xa3, 0xa3, 0x60, 0xf2, 0x23, 0xac, 0xa5, 0x28, 0x13, 0xc1, 0x25, 0x06,
	0x9d, 0x38, 0x94, 0x12, 0xf3, 0x72, 0x78, 0x7b, 0x1a, 0x60, 0x16, 0xb5, 0xab, 0x83, 0xe8, 0x6a,
	0x5a, 0x9c, 0xa2, 0x24, 0x2f, 0xe1, 0x52, 0x56, 0x0a, 0x64, 0x5e, 0x5e, 0xb2, 0xcb, 0xdf, 0x9f,
	0x81, 0x0e, 0x5b, 0x57, 0x64, 0xb1, 0xb0, 0xd8, 0x5a, 0x65, 0x6d, 0xe4, 0x1a, 0xd4, 0x98, 0x0c,
	0x4c, 0xb2, 0xc3, 0xa3, 0x18, 0x1b, 0x15, 0xa3, 0x3e, 0x97, 0x49, 0x9a, 0x9b, 0xc8, 0x5d, 0x58,
	0x52, 0xac, 0x8f, 0x62, 0xa0, 0x6c, 0xdd, 0x79, 0xcf, 0xcf, 0x3a, 0x03, 0x3f, 0xef, 0x0c, 0xfc,
	0x3d, 0xdb, 0x19, 0xd0, 0xdc, 0xb3, 0xf9, 0x10, 0xc8, 0xf8, 0xe6, 0x73, 0x3d, 0xf2, 0x5f, 0x4b,
	0xe0, 0x16, 0x14, 0x41, 0x3e, 0x84, 0x4c, 0x13, 0x81, 0xd9, 0xca, 0x60, 0x94, 0x29, 0x18, 0x13,
	0xd5, 0x16, 0x72, 0x17, 0x2e, 0xf7, 0x19, 0x37, 0x77, 0x61, 0x28, 0x83, 0x04, 0xd3, 0x40, 0xa2,
	0x26, 0xc8, 0x60, 0xd7, 0xe9, 0x3b, 0x7d, 0xc6, 0x69, 0xb6, 0xf8, 0x1c, 0xd3, 0x43, 0xb3, 0x44,
	0x6e, 0x83, 0xa3, 0x54, 0x6c, 0x3f, 0xd6, 0x13, 0x2e, 0xa6, 0xbd, 0xbc, 0x21, 0xd4, 0xcf, 0xb1,
	0x45, 0x1e, 0x8f, 0xcb, 0x67, 0x46, 0xb6, 0xc7, 0xf4, 0xf3, 0x3e, 0x00, 0x93, 0xc1, 0xab, 0x90,
	0xc5, 0x83, 0x34, 0xcb, 0xc6, 0x32, 0x5d, 0x61, 0xf2, 0xdb, 0xcc, 0xe0, 0xfd, 0xee, 0x40, 0xad,
	0x28, 0x3d, 0xb2, 0x03, 0x4e, 0x18, 0xc7, 0x76, 0x53, 0x7f, 0x76, 0xcd, 0xfa, 0x87, 0xf8, 0xda,
	0xf4, 0x3c, 0x71, 0x6c, 0x30, 0xf8, 0xd0, 0x3e, 0xce, 0xb7, 0xc1, 0xe0, 0x43, 0xf2, 0x0d, 0x38,
	0x5c, 0x28, 0x9b, 0xc0, 0x39, 0xde, 0x8e, 0x8e, 0xe7, 0x42, 0x91, 0xaf, 0x6d, 0xfb, 0x57, 0x31,
	0x00, 0x1f, 0x4f, 0x29, 0x69, 0xa1, 0xea, 0xe5, 0xd1, 0x59, 0xa7, 0xb8, 0x0d, 0xd5, 0x3e, 0xaa,
	0x9e, 0x88, 0xac, 0x36, 0xff, 0x03, 0xa0, 0xd0, 0xa6, 0xb6, 0x95, 0x4a, 0x9e, 0x18, 0x77, 0xdd,
	0xb8, 0x65, 0x81, 0xcd, 0xef, 0xc1, 0x39, 0xc4, 0xd7, 0x64, 0x0f, 0x96, 0xfa, 0x1a, 0x1a, 0x67,
	0x6c, 0x88, 0xce, 0x15, 0x82, 0x3c, 0x74, 0x67, 0x09, 0x16, 0xcd, 0xd0, 0xbb, 0x06, 0x2b, 0x67,
	0xa7, 0xd5, 0x2a, 0x4f, 0xb1, 0x8b, 0xa7, 0x56, 0xf9, 0xd9, 0xc4, 0x7b, 0x53, 0x1e, 0xe9, 0x29,
	0xf3, 0xdb, 0x2d, 0x92, 0xba, 0x39, 0x87, 0x92, 0x8a, 0xac, 0xee, 0x16, 0x59, 0x7d, 0x2b, 0x10,
	0x3e, 0x24, 0x5b, 0x45, 0x5a, 0xe7, 0xd1, 0x74, 0xce, 0xeb, 0x3e, 0x54, 0xa5, 0x0a, 0xd5, 0x40,
	0x5a, 0x66, 0xa7, 0x7c, 0xac, 0x34, 0x33, 0x87, 0xc6, 0x9f, 0x86, 0xbc, 0x8b, 0x9a, 0x9e, 0x2c,
	0xbc, 0x79, 0x90, 0xd1, 0xf3, 0xe8, 0x22, 0x3d, 0x73, 0x3d, 0xb4, 0x71, 0x7e, 0x3e, 0x83, 0xd5,
	0x0b, 0x7b, 0xea, 0xea, 0xd4, 0x67, 0xd9, 0x3b, 0xae, 0x53, 0x3d, 0x34, 0x96, 0xf0, 0xd4, 0xd6,
	0x0f, 0x3d, 0xf4, 0x76, 0xc1, 0x2d, 0x7c, 0x57, 0xc8, 0x15, 0x58, 0x39, 0xeb, 0x6f, 0x2c, 0xb9,
	0x23, 0x43, 0xa1, 0x63, 0x2c, 0x17, 0x3b, 0xc6, 0xd6, 0x5f, 0x25, 0x70, 0x8b, 0x7f, 0x8d, 0x5e,
	0x82, 0xb3, 0x8f, 0x8a, 0x7c, 0x3a, 0xf9, 0x46, 0xe7, 0xff, 0x4f, 0x35, 0x3f, 0x9a, 0xec, 0x9d,
	0xfd, 0x33, 0xf2, 0x16, 0xee, 0x94, 0x48, 0x02, 0xb0, 0x8f, 0x2a, 0xff, 0xae, 0xcf, 0xb7, 0xcb,
	0x9d, 0xc9, 0xde, 0xe3, 0x7d, 0x83, 0xde, 0x71, 0xe7, 0xfe, 0xcf, 0xf7, 0xba, 0x4c, 0xf5, 0x06,
	0x47, 0x7e, 0x47, 0xf4, 0x37, 0x6d, 0x78, 0xfe, 0xdb, 0xda, 0x30, 0x38, 0x1b, 0x61, 0xc2, 0x36,
	0xbb, 0x62, 0xb3, 0x00, 0x77, 0x54, 0x35, 0x85, 0xf7, 0xee, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x3d, 0x49, 0x65, 0x10, 0xac, 0x0e, 0x00, 0x00,
}
