// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.30.2
// source: outbound.proto

package outbound

import (
	duration "github.com/golang/protobuf/ptypes/duration"
	destination "github.com/linkerd/linkerd2-proxy-api/go/destination"
	grpc_route "github.com/linkerd/linkerd2-proxy-api/go/grpc_route"
	http_route "github.com/linkerd/linkerd2-proxy-api/go/http_route"
	meta "github.com/linkerd/linkerd2-proxy-api/go/meta"
	net "github.com/linkerd/linkerd2-proxy-api/go/net"
	opaque_route "github.com/linkerd/linkerd2-proxy-api/go/opaque_route"
	tls_route "github.com/linkerd/linkerd2-proxy-api/go/tls_route"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TrafficSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Uniquely identifies the source proxy workload (e.g., pod name) to the
	// control plane.
	SourceWorkload string `protobuf:"bytes,1,opt,name=source_workload,json=sourceWorkload,proto3" json:"source_workload,omitempty"`
	// Describes a target address, as observed by the proxy.
	//
	// Types that are valid to be assigned to Target:
	//
	//	*TrafficSpec_Addr
	//	*TrafficSpec_Authority
	Target        isTrafficSpec_Target `protobuf_oneof:"target"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TrafficSpec) Reset() {
	*x = TrafficSpec{}
	mi := &file_outbound_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrafficSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrafficSpec) ProtoMessage() {}

func (x *TrafficSpec) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TrafficSpec.ProtoReflect.Descriptor instead.
func (*TrafficSpec) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{0}
}

func (x *TrafficSpec) GetSourceWorkload() string {
	if x != nil {
		return x.SourceWorkload
	}
	return ""
}

func (x *TrafficSpec) GetTarget() isTrafficSpec_Target {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *TrafficSpec) GetAddr() *net.TcpAddress {
	if x != nil {
		if x, ok := x.Target.(*TrafficSpec_Addr); ok {
			return x.Addr
		}
	}
	return nil
}

func (x *TrafficSpec) GetAuthority() string {
	if x != nil {
		if x, ok := x.Target.(*TrafficSpec_Authority); ok {
			return x.Authority
		}
	}
	return ""
}

type isTrafficSpec_Target interface {
	isTrafficSpec_Target()
}

type TrafficSpec_Addr struct {
	// Indicates the proxy is connecting to a specific IP:port.
	Addr *net.TcpAddress `protobuf:"bytes,2,opt,name=addr,proto3,oneof"`
}

type TrafficSpec_Authority struct {
	// Indicates the proxy is connecting to a named address (like an HTTP
	// authority).
	Authority string `protobuf:"bytes,3,opt,name=authority,proto3,oneof"`
}

func (*TrafficSpec_Addr) isTrafficSpec_Target() {}

func (*TrafficSpec_Authority) isTrafficSpec_Target() {}

// Outbound policy for a given traffic spec.
type OutboundPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates the protocol to use for this target. This will be set to Opaque
	// if the target has been marked as opaque and will be Discover otherwise.
	Protocol *ProxyProtocol `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Describes the resource for which outbound policy has been discovered.
	Metadata      *meta.Metadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutboundPolicy) Reset() {
	*x = OutboundPolicy{}
	mi := &file_outbound_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutboundPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutboundPolicy) ProtoMessage() {}

func (x *OutboundPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutboundPolicy.ProtoReflect.Descriptor instead.
func (*OutboundPolicy) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{1}
}

func (x *OutboundPolicy) GetProtocol() *ProxyProtocol {
	if x != nil {
		return x.Protocol
	}
	return nil
}

func (x *OutboundPolicy) GetMetadata() *meta.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type ProxyProtocol struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*ProxyProtocol_Detect_
	//	*ProxyProtocol_Opaque_
	//	*ProxyProtocol_Http1_
	//	*ProxyProtocol_Http2_
	//	*ProxyProtocol_Grpc_
	//	*ProxyProtocol_Tls_
	Kind          isProxyProtocol_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyProtocol) Reset() {
	*x = ProxyProtocol{}
	mi := &file_outbound_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol) ProtoMessage() {}

func (x *ProxyProtocol) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol.ProtoReflect.Descriptor instead.
func (*ProxyProtocol) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2}
}

func (x *ProxyProtocol) GetKind() isProxyProtocol_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *ProxyProtocol) GetDetect() *ProxyProtocol_Detect {
	if x != nil {
		if x, ok := x.Kind.(*ProxyProtocol_Detect_); ok {
			return x.Detect
		}
	}
	return nil
}

func (x *ProxyProtocol) GetOpaque() *ProxyProtocol_Opaque {
	if x != nil {
		if x, ok := x.Kind.(*ProxyProtocol_Opaque_); ok {
			return x.Opaque
		}
	}
	return nil
}

func (x *ProxyProtocol) GetHttp1() *ProxyProtocol_Http1 {
	if x != nil {
		if x, ok := x.Kind.(*ProxyProtocol_Http1_); ok {
			return x.Http1
		}
	}
	return nil
}

func (x *ProxyProtocol) GetHttp2() *ProxyProtocol_Http2 {
	if x != nil {
		if x, ok := x.Kind.(*ProxyProtocol_Http2_); ok {
			return x.Http2
		}
	}
	return nil
}

func (x *ProxyProtocol) GetGrpc() *ProxyProtocol_Grpc {
	if x != nil {
		if x, ok := x.Kind.(*ProxyProtocol_Grpc_); ok {
			return x.Grpc
		}
	}
	return nil
}

func (x *ProxyProtocol) GetTls() *ProxyProtocol_Tls {
	if x != nil {
		if x, ok := x.Kind.(*ProxyProtocol_Tls_); ok {
			return x.Tls
		}
	}
	return nil
}

type isProxyProtocol_Kind interface {
	isProxyProtocol_Kind()
}

type ProxyProtocol_Detect_ struct {
	Detect *ProxyProtocol_Detect `protobuf:"bytes,1,opt,name=detect,proto3,oneof"`
}

type ProxyProtocol_Opaque_ struct {
	Opaque *ProxyProtocol_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof"`
}

type ProxyProtocol_Http1_ struct {
	// HTTP/1 policy configuration.
	Http1 *ProxyProtocol_Http1 `protobuf:"bytes,3,opt,name=http1,proto3,oneof"`
}

type ProxyProtocol_Http2_ struct {
	// HTTP/2 policy configuration.
	Http2 *ProxyProtocol_Http2 `protobuf:"bytes,4,opt,name=http2,proto3,oneof"`
}

type ProxyProtocol_Grpc_ struct {
	// gRPC policy configuration.
	Grpc *ProxyProtocol_Grpc `protobuf:"bytes,5,opt,name=grpc,proto3,oneof"`
}

type ProxyProtocol_Tls_ struct {
	// TLS policy configuration.
	Tls *ProxyProtocol_Tls `protobuf:"bytes,6,opt,name=tls,proto3,oneof"`
}

func (*ProxyProtocol_Detect_) isProxyProtocol_Kind() {}

func (*ProxyProtocol_Opaque_) isProxyProtocol_Kind() {}

func (*ProxyProtocol_Http1_) isProxyProtocol_Kind() {}

func (*ProxyProtocol_Http2_) isProxyProtocol_Kind() {}

func (*ProxyProtocol_Grpc_) isProxyProtocol_Kind() {}

func (*ProxyProtocol_Tls_) isProxyProtocol_Kind() {}

// Outbound-specific HTTP route configuration (based on the
// [Gateway API](https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.HTTPRoute)).
type HttpRoute struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *meta.Metadata         `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// If empty, the host value is ignored.
	Hosts []*http_route.HostMatch `protobuf:"bytes,2,rep,name=hosts,proto3" json:"hosts,omitempty"`
	// Must have at least one rule.
	Rules         []*HttpRoute_Rule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute) Reset() {
	*x = HttpRoute{}
	mi := &file_outbound_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute) ProtoMessage() {}

func (x *HttpRoute) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute.ProtoReflect.Descriptor instead.
func (*HttpRoute) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3}
}

func (x *HttpRoute) GetMetadata() *meta.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *HttpRoute) GetHosts() []*http_route.HostMatch {
	if x != nil {
		return x.Hosts
	}
	return nil
}

func (x *HttpRoute) GetRules() []*HttpRoute_Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type GrpcRoute struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *meta.Metadata         `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// If empty, the host value is ignored.
	Hosts []*http_route.HostMatch `protobuf:"bytes,2,rep,name=hosts,proto3" json:"hosts,omitempty"`
	// Must have at least one rule.
	Rules         []*GrpcRoute_Rule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute) Reset() {
	*x = GrpcRoute{}
	mi := &file_outbound_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute) ProtoMessage() {}

func (x *GrpcRoute) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute.ProtoReflect.Descriptor instead.
func (*GrpcRoute) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4}
}

func (x *GrpcRoute) GetMetadata() *meta.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *GrpcRoute) GetHosts() []*http_route.HostMatch {
	if x != nil {
		return x.Hosts
	}
	return nil
}

func (x *GrpcRoute) GetRules() []*GrpcRoute_Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type OpaqueRoute struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *meta.Metadata         `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Must have at least one rule.
	Rules         []*OpaqueRoute_Rule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute) Reset() {
	*x = OpaqueRoute{}
	mi := &file_outbound_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute) ProtoMessage() {}

func (x *OpaqueRoute) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute.ProtoReflect.Descriptor instead.
func (*OpaqueRoute) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5}
}

func (x *OpaqueRoute) GetMetadata() *meta.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *OpaqueRoute) GetRules() []*OpaqueRoute_Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type TlsRoute struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *meta.Metadata         `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// If empty, the SNI value is ignored.
	Snis []*tls_route.SniMatch `protobuf:"bytes,2,rep,name=snis,proto3" json:"snis,omitempty"`
	// Must have at least one rule.
	Rules         []*TlsRoute_Rule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute) Reset() {
	*x = TlsRoute{}
	mi := &file_outbound_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute) ProtoMessage() {}

func (x *TlsRoute) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute.ProtoReflect.Descriptor instead.
func (*TlsRoute) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6}
}

func (x *TlsRoute) GetMetadata() *meta.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *TlsRoute) GetSnis() []*tls_route.SniMatch {
	if x != nil {
		return x.Snis
	}
	return nil
}

func (x *TlsRoute) GetRules() []*TlsRoute_Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type Backend struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *meta.Metadata         `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Types that are valid to be assigned to Kind:
	//
	//	*Backend_Forward
	//	*Backend_Balancer
	Kind isBackend_Kind `protobuf_oneof:"kind"`
	// Describes queue configuration for a backend.
	Queue         *Queue `protobuf:"bytes,4,opt,name=queue,proto3" json:"queue,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend) Reset() {
	*x = Backend{}
	mi := &file_outbound_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend) ProtoMessage() {}

func (x *Backend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend.ProtoReflect.Descriptor instead.
func (*Backend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{7}
}

func (x *Backend) GetMetadata() *meta.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Backend) GetKind() isBackend_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *Backend) GetForward() *destination.WeightedAddr {
	if x != nil {
		if x, ok := x.Kind.(*Backend_Forward); ok {
			return x.Forward
		}
	}
	return nil
}

func (x *Backend) GetBalancer() *Backend_BalanceP2C {
	if x != nil {
		if x, ok := x.Kind.(*Backend_Balancer); ok {
			return x.Balancer
		}
	}
	return nil
}

func (x *Backend) GetQueue() *Queue {
	if x != nil {
		return x.Queue
	}
	return nil
}

type isBackend_Kind interface {
	isBackend_Kind()
}

type Backend_Forward struct {
	// A backend that consists of a single endpoint.
	Forward *destination.WeightedAddr `protobuf:"bytes,2,opt,name=forward,proto3,oneof"`
}

type Backend_Balancer struct {
	// A backend that comprises a load balanced service.
	Balancer *Backend_BalanceP2C `protobuf:"bytes,3,opt,name=balancer,proto3,oneof"`
}

func (*Backend_Forward) isBackend_Kind() {}

func (*Backend_Balancer) isBackend_Kind() {}

type Queue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of requests that may be held in a queue before backpressure is
	// exerted.
	Capacity uint32 `protobuf:"varint,1,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// A timeout that limits how long a backend may remain unready before any
	// requests in its queue are failed.
	FailfastTimeout *duration.Duration `protobuf:"bytes,2,opt,name=failfast_timeout,json=failfastTimeout,proto3" json:"failfast_timeout,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Queue) Reset() {
	*x = Queue{}
	mi := &file_outbound_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Queue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Queue) ProtoMessage() {}

func (x *Queue) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Queue.ProtoReflect.Descriptor instead.
func (*Queue) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{8}
}

func (x *Queue) GetCapacity() uint32 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *Queue) GetFailfastTimeout() *duration.Duration {
	if x != nil {
		return x.FailfastTimeout
	}
	return nil
}

type FailureAccrual struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*FailureAccrual_ConsecutiveFailures_
	Kind          isFailureAccrual_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FailureAccrual) Reset() {
	*x = FailureAccrual{}
	mi := &file_outbound_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FailureAccrual) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FailureAccrual) ProtoMessage() {}

func (x *FailureAccrual) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FailureAccrual.ProtoReflect.Descriptor instead.
func (*FailureAccrual) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{9}
}

func (x *FailureAccrual) GetKind() isFailureAccrual_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *FailureAccrual) GetConsecutiveFailures() *FailureAccrual_ConsecutiveFailures {
	if x != nil {
		if x, ok := x.Kind.(*FailureAccrual_ConsecutiveFailures_); ok {
			return x.ConsecutiveFailures
		}
	}
	return nil
}

type isFailureAccrual_Kind interface {
	isFailureAccrual_Kind()
}

type FailureAccrual_ConsecutiveFailures_ struct {
	ConsecutiveFailures *FailureAccrual_ConsecutiveFailures `protobuf:"bytes,1,opt,name=consecutive_failures,json=consecutiveFailures,proto3,oneof"`
}

func (*FailureAccrual_ConsecutiveFailures_) isFailureAccrual_Kind() {}

type ExponentialBackoff struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The minimum amount of time to wait before resuming an operation.
	MinBackoff *duration.Duration `protobuf:"bytes,1,opt,name=min_backoff,json=minBackoff,proto3" json:"min_backoff,omitempty"`
	// The maximum amount of time to wait before resuming an operation.
	// Must be greater than or equal to min_backoff.
	MaxBackoff *duration.Duration `protobuf:"bytes,2,opt,name=max_backoff,json=maxBackoff,proto3" json:"max_backoff,omitempty"`
	// The ratio of the base timeout that may be randomly added to a backoff.
	// Must be greater than or equal to 0.0.
	JitterRatio   float32 `protobuf:"fixed32,3,opt,name=jitter_ratio,json=jitterRatio,proto3" json:"jitter_ratio,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExponentialBackoff) Reset() {
	*x = ExponentialBackoff{}
	mi := &file_outbound_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExponentialBackoff) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExponentialBackoff) ProtoMessage() {}

func (x *ExponentialBackoff) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExponentialBackoff.ProtoReflect.Descriptor instead.
func (*ExponentialBackoff) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{10}
}

func (x *ExponentialBackoff) GetMinBackoff() *duration.Duration {
	if x != nil {
		return x.MinBackoff
	}
	return nil
}

func (x *ExponentialBackoff) GetMaxBackoff() *duration.Duration {
	if x != nil {
		return x.MaxBackoff
	}
	return nil
}

func (x *ExponentialBackoff) GetJitterRatio() float32 {
	if x != nil {
		return x.JitterRatio
	}
	return 0
}

type ProxyProtocol_Detect struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Protocol detection timeout.
	Timeout *duration.Duration    `protobuf:"bytes,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Opaque  *ProxyProtocol_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// HTTP/1 policy configuration.
	Http1 *ProxyProtocol_Http1 `protobuf:"bytes,3,opt,name=http1,proto3" json:"http1,omitempty"`
	// HTTP/2 policy configuration.
	Http2         *ProxyProtocol_Http2 `protobuf:"bytes,4,opt,name=http2,proto3" json:"http2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyProtocol_Detect) Reset() {
	*x = ProxyProtocol_Detect{}
	mi := &file_outbound_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol_Detect) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol_Detect) ProtoMessage() {}

func (x *ProxyProtocol_Detect) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol_Detect.ProtoReflect.Descriptor instead.
func (*ProxyProtocol_Detect) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2, 0}
}

func (x *ProxyProtocol_Detect) GetTimeout() *duration.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *ProxyProtocol_Detect) GetOpaque() *ProxyProtocol_Opaque {
	if x != nil {
		return x.Opaque
	}
	return nil
}

func (x *ProxyProtocol_Detect) GetHttp1() *ProxyProtocol_Http1 {
	if x != nil {
		return x.Http1
	}
	return nil
}

func (x *ProxyProtocol_Detect) GetHttp2() *ProxyProtocol_Http2 {
	if x != nil {
		return x.Http2
	}
	return nil
}

type ProxyProtocol_Opaque struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Routes        []*OpaqueRoute         `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyProtocol_Opaque) Reset() {
	*x = ProxyProtocol_Opaque{}
	mi := &file_outbound_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol_Opaque) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol_Opaque) ProtoMessage() {}

func (x *ProxyProtocol_Opaque) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol_Opaque.ProtoReflect.Descriptor instead.
func (*ProxyProtocol_Opaque) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2, 1}
}

func (x *ProxyProtocol_Opaque) GetRoutes() []*OpaqueRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

type ProxyProtocol_Http1 struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Routes []*HttpRoute           `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// If empty, circuit breaking is not performed.
	FailureAccrual *FailureAccrual `protobuf:"bytes,2,opt,name=failure_accrual,json=failureAccrual,proto3" json:"failure_accrual,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ProxyProtocol_Http1) Reset() {
	*x = ProxyProtocol_Http1{}
	mi := &file_outbound_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol_Http1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol_Http1) ProtoMessage() {}

func (x *ProxyProtocol_Http1) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol_Http1.ProtoReflect.Descriptor instead.
func (*ProxyProtocol_Http1) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2, 2}
}

func (x *ProxyProtocol_Http1) GetRoutes() []*HttpRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *ProxyProtocol_Http1) GetFailureAccrual() *FailureAccrual {
	if x != nil {
		return x.FailureAccrual
	}
	return nil
}

type ProxyProtocol_Http2 struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Routes []*HttpRoute           `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// If empty, circuit breaking is not performed.
	FailureAccrual *FailureAccrual `protobuf:"bytes,2,opt,name=failure_accrual,json=failureAccrual,proto3" json:"failure_accrual,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ProxyProtocol_Http2) Reset() {
	*x = ProxyProtocol_Http2{}
	mi := &file_outbound_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol_Http2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol_Http2) ProtoMessage() {}

func (x *ProxyProtocol_Http2) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol_Http2.ProtoReflect.Descriptor instead.
func (*ProxyProtocol_Http2) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2, 3}
}

func (x *ProxyProtocol_Http2) GetRoutes() []*HttpRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *ProxyProtocol_Http2) GetFailureAccrual() *FailureAccrual {
	if x != nil {
		return x.FailureAccrual
	}
	return nil
}

type ProxyProtocol_Grpc struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Routes []*GrpcRoute           `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// If empty, circuit breaking is not performed.
	FailureAccrual *FailureAccrual `protobuf:"bytes,2,opt,name=failure_accrual,json=failureAccrual,proto3" json:"failure_accrual,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ProxyProtocol_Grpc) Reset() {
	*x = ProxyProtocol_Grpc{}
	mi := &file_outbound_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol_Grpc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol_Grpc) ProtoMessage() {}

func (x *ProxyProtocol_Grpc) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol_Grpc.ProtoReflect.Descriptor instead.
func (*ProxyProtocol_Grpc) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2, 4}
}

func (x *ProxyProtocol_Grpc) GetRoutes() []*GrpcRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *ProxyProtocol_Grpc) GetFailureAccrual() *FailureAccrual {
	if x != nil {
		return x.FailureAccrual
	}
	return nil
}

type ProxyProtocol_Tls struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Routes        []*TlsRoute            `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyProtocol_Tls) Reset() {
	*x = ProxyProtocol_Tls{}
	mi := &file_outbound_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyProtocol_Tls) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyProtocol_Tls) ProtoMessage() {}

func (x *ProxyProtocol_Tls) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyProtocol_Tls.ProtoReflect.Descriptor instead.
func (*ProxyProtocol_Tls) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{2, 5}
}

func (x *ProxyProtocol_Tls) GetRoutes() []*TlsRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

type HttpRoute_Rule struct {
	state    protoimpl.MessageState       `protogen:"open.v1"`
	Matches  []*http_route.HttpRouteMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	Filters  []*HttpRoute_Filter          `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	Backends *HttpRoute_Distribution      `protobuf:"bytes,3,opt,name=backends,proto3" json:"backends,omitempty"`
	// DEPRECATED: use `timeouts` instead. Servers should continue to set this
	// value to the same value as `timeouts.response`.
	//
	// Deprecated: Marked as deprecated in outbound.proto.
	RequestTimeout *duration.Duration   `protobuf:"bytes,4,opt,name=requestTimeout,proto3" json:"requestTimeout,omitempty"`
	Timeouts       *http_route.Timeouts `protobuf:"bytes,5,opt,name=timeouts,proto3" json:"timeouts,omitempty"`
	Retry          *HttpRoute_Retry     `protobuf:"bytes,6,opt,name=retry,proto3" json:"retry,omitempty"`
	// If true, the proxy will allow headers to control retry and timeout
	// behavior.
	AllowL5DRequestHeaders bool `protobuf:"varint,7,opt,name=allow_l5d_request_headers,json=allowL5dRequestHeaders,proto3" json:"allow_l5d_request_headers,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *HttpRoute_Rule) Reset() {
	*x = HttpRoute_Rule{}
	mi := &file_outbound_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Rule) ProtoMessage() {}

func (x *HttpRoute_Rule) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Rule.ProtoReflect.Descriptor instead.
func (*HttpRoute_Rule) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 0}
}

func (x *HttpRoute_Rule) GetMatches() []*http_route.HttpRouteMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *HttpRoute_Rule) GetFilters() []*HttpRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *HttpRoute_Rule) GetBackends() *HttpRoute_Distribution {
	if x != nil {
		return x.Backends
	}
	return nil
}

// Deprecated: Marked as deprecated in outbound.proto.
func (x *HttpRoute_Rule) GetRequestTimeout() *duration.Duration {
	if x != nil {
		return x.RequestTimeout
	}
	return nil
}

func (x *HttpRoute_Rule) GetTimeouts() *http_route.Timeouts {
	if x != nil {
		return x.Timeouts
	}
	return nil
}

func (x *HttpRoute_Rule) GetRetry() *HttpRoute_Retry {
	if x != nil {
		return x.Retry
	}
	return nil
}

func (x *HttpRoute_Rule) GetAllowL5DRequestHeaders() bool {
	if x != nil {
		return x.AllowL5DRequestHeaders
	}
	return false
}

type HttpRoute_Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*HttpRoute_Filter_FailureInjector
	//	*HttpRoute_Filter_RequestHeaderModifier
	//	*HttpRoute_Filter_Redirect
	//	*HttpRoute_Filter_ResponseHeaderModifier
	Kind          isHttpRoute_Filter_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Filter) Reset() {
	*x = HttpRoute_Filter{}
	mi := &file_outbound_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Filter) ProtoMessage() {}

func (x *HttpRoute_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Filter.ProtoReflect.Descriptor instead.
func (*HttpRoute_Filter) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 1}
}

func (x *HttpRoute_Filter) GetKind() isHttpRoute_Filter_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *HttpRoute_Filter) GetFailureInjector() *http_route.HttpFailureInjector {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Filter_FailureInjector); ok {
			return x.FailureInjector
		}
	}
	return nil
}

func (x *HttpRoute_Filter) GetRequestHeaderModifier() *http_route.RequestHeaderModifier {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Filter_RequestHeaderModifier); ok {
			return x.RequestHeaderModifier
		}
	}
	return nil
}

func (x *HttpRoute_Filter) GetRedirect() *http_route.RequestRedirect {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Filter_Redirect); ok {
			return x.Redirect
		}
	}
	return nil
}

func (x *HttpRoute_Filter) GetResponseHeaderModifier() *http_route.ResponseHeaderModifier {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Filter_ResponseHeaderModifier); ok {
			return x.ResponseHeaderModifier
		}
	}
	return nil
}

type isHttpRoute_Filter_Kind interface {
	isHttpRoute_Filter_Kind()
}

type HttpRoute_Filter_FailureInjector struct {
	FailureInjector *http_route.HttpFailureInjector `protobuf:"bytes,1,opt,name=failure_injector,json=failureInjector,proto3,oneof"`
}

type HttpRoute_Filter_RequestHeaderModifier struct {
	RequestHeaderModifier *http_route.RequestHeaderModifier `protobuf:"bytes,2,opt,name=request_header_modifier,json=requestHeaderModifier,proto3,oneof"`
}

type HttpRoute_Filter_Redirect struct {
	Redirect *http_route.RequestRedirect `protobuf:"bytes,3,opt,name=redirect,proto3,oneof"`
}

type HttpRoute_Filter_ResponseHeaderModifier struct {
	ResponseHeaderModifier *http_route.ResponseHeaderModifier `protobuf:"bytes,4,opt,name=response_header_modifier,json=responseHeaderModifier,proto3,oneof"`
}

func (*HttpRoute_Filter_FailureInjector) isHttpRoute_Filter_Kind() {}

func (*HttpRoute_Filter_RequestHeaderModifier) isHttpRoute_Filter_Kind() {}

func (*HttpRoute_Filter_Redirect) isHttpRoute_Filter_Kind() {}

func (*HttpRoute_Filter_ResponseHeaderModifier) isHttpRoute_Filter_Kind() {}

type HttpRoute_Distribution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*HttpRoute_Distribution_Empty_
	//	*HttpRoute_Distribution_FirstAvailable_
	//	*HttpRoute_Distribution_RandomAvailable_
	Kind          isHttpRoute_Distribution_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Distribution) Reset() {
	*x = HttpRoute_Distribution{}
	mi := &file_outbound_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Distribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Distribution) ProtoMessage() {}

func (x *HttpRoute_Distribution) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Distribution.ProtoReflect.Descriptor instead.
func (*HttpRoute_Distribution) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 2}
}

func (x *HttpRoute_Distribution) GetKind() isHttpRoute_Distribution_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *HttpRoute_Distribution) GetEmpty() *HttpRoute_Distribution_Empty {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Distribution_Empty_); ok {
			return x.Empty
		}
	}
	return nil
}

func (x *HttpRoute_Distribution) GetFirstAvailable() *HttpRoute_Distribution_FirstAvailable {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Distribution_FirstAvailable_); ok {
			return x.FirstAvailable
		}
	}
	return nil
}

func (x *HttpRoute_Distribution) GetRandomAvailable() *HttpRoute_Distribution_RandomAvailable {
	if x != nil {
		if x, ok := x.Kind.(*HttpRoute_Distribution_RandomAvailable_); ok {
			return x.RandomAvailable
		}
	}
	return nil
}

type isHttpRoute_Distribution_Kind interface {
	isHttpRoute_Distribution_Kind()
}

type HttpRoute_Distribution_Empty_ struct {
	Empty *HttpRoute_Distribution_Empty `protobuf:"bytes,1,opt,name=empty,proto3,oneof"`
}

type HttpRoute_Distribution_FirstAvailable_ struct {
	// Use the first available backend in the list.
	FirstAvailable *HttpRoute_Distribution_FirstAvailable `protobuf:"bytes,2,opt,name=first_available,json=firstAvailable,proto3,oneof"`
}

type HttpRoute_Distribution_RandomAvailable_ struct {
	RandomAvailable *HttpRoute_Distribution_RandomAvailable `protobuf:"bytes,3,opt,name=random_available,json=randomAvailable,proto3,oneof"`
}

func (*HttpRoute_Distribution_Empty_) isHttpRoute_Distribution_Kind() {}

func (*HttpRoute_Distribution_FirstAvailable_) isHttpRoute_Distribution_Kind() {}

func (*HttpRoute_Distribution_RandomAvailable_) isHttpRoute_Distribution_Kind() {}

type HttpRoute_Retry struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	MaxRetries      uint32                 `protobuf:"varint,1,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	MaxRequestBytes uint32                 `protobuf:"varint,2,opt,name=max_request_bytes,json=maxRequestBytes,proto3" json:"max_request_bytes,omitempty"`
	// Must be set, even if there are no internal conditions.
	Conditions    *HttpRoute_Retry_Conditions `protobuf:"bytes,3,opt,name=conditions,proto3" json:"conditions,omitempty"`
	Timeout       *duration.Duration          `protobuf:"bytes,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Backoff       *ExponentialBackoff         `protobuf:"bytes,5,opt,name=backoff,proto3" json:"backoff,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Retry) Reset() {
	*x = HttpRoute_Retry{}
	mi := &file_outbound_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Retry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Retry) ProtoMessage() {}

func (x *HttpRoute_Retry) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Retry.ProtoReflect.Descriptor instead.
func (*HttpRoute_Retry) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 3}
}

func (x *HttpRoute_Retry) GetMaxRetries() uint32 {
	if x != nil {
		return x.MaxRetries
	}
	return 0
}

func (x *HttpRoute_Retry) GetMaxRequestBytes() uint32 {
	if x != nil {
		return x.MaxRequestBytes
	}
	return 0
}

func (x *HttpRoute_Retry) GetConditions() *HttpRoute_Retry_Conditions {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *HttpRoute_Retry) GetTimeout() *duration.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *HttpRoute_Retry) GetBackoff() *ExponentialBackoff {
	if x != nil {
		return x.Backoff
	}
	return nil
}

type HttpRoute_RouteBackend struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Backend *Backend               `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Filters []*HttpRoute_Filter    `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	// DEPRECATED: proxies ignore this. Use Retry timeouts instead.
	//
	// Deprecated: Marked as deprecated in outbound.proto.
	RequestTimeout *duration.Duration `protobuf:"bytes,4,opt,name=requestTimeout,proto3" json:"requestTimeout,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *HttpRoute_RouteBackend) Reset() {
	*x = HttpRoute_RouteBackend{}
	mi := &file_outbound_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_RouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_RouteBackend) ProtoMessage() {}

func (x *HttpRoute_RouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_RouteBackend.ProtoReflect.Descriptor instead.
func (*HttpRoute_RouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 4}
}

func (x *HttpRoute_RouteBackend) GetBackend() *Backend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *HttpRoute_RouteBackend) GetFilters() []*HttpRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// Deprecated: Marked as deprecated in outbound.proto.
func (x *HttpRoute_RouteBackend) GetRequestTimeout() *duration.Duration {
	if x != nil {
		return x.RequestTimeout
	}
	return nil
}

type HttpRoute_WeightedRouteBackend struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	Backend       *HttpRoute_RouteBackend `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Weight        uint32                  `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_WeightedRouteBackend) Reset() {
	*x = HttpRoute_WeightedRouteBackend{}
	mi := &file_outbound_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_WeightedRouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_WeightedRouteBackend) ProtoMessage() {}

func (x *HttpRoute_WeightedRouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_WeightedRouteBackend.ProtoReflect.Descriptor instead.
func (*HttpRoute_WeightedRouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 5}
}

func (x *HttpRoute_WeightedRouteBackend) GetBackend() *HttpRoute_RouteBackend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *HttpRoute_WeightedRouteBackend) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type HttpRoute_Distribution_Empty struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Distribution_Empty) Reset() {
	*x = HttpRoute_Distribution_Empty{}
	mi := &file_outbound_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Distribution_Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Distribution_Empty) ProtoMessage() {}

func (x *HttpRoute_Distribution_Empty) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Distribution_Empty.ProtoReflect.Descriptor instead.
func (*HttpRoute_Distribution_Empty) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 2, 0}
}

type HttpRoute_Distribution_FirstAvailable struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Backends      []*HttpRoute_RouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Distribution_FirstAvailable) Reset() {
	*x = HttpRoute_Distribution_FirstAvailable{}
	mi := &file_outbound_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Distribution_FirstAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Distribution_FirstAvailable) ProtoMessage() {}

func (x *HttpRoute_Distribution_FirstAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Distribution_FirstAvailable.ProtoReflect.Descriptor instead.
func (*HttpRoute_Distribution_FirstAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 2, 1}
}

func (x *HttpRoute_Distribution_FirstAvailable) GetBackends() []*HttpRoute_RouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

type HttpRoute_Distribution_RandomAvailable struct {
	state         protoimpl.MessageState            `protogen:"open.v1"`
	Backends      []*HttpRoute_WeightedRouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Distribution_RandomAvailable) Reset() {
	*x = HttpRoute_Distribution_RandomAvailable{}
	mi := &file_outbound_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Distribution_RandomAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Distribution_RandomAvailable) ProtoMessage() {}

func (x *HttpRoute_Distribution_RandomAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Distribution_RandomAvailable.ProtoReflect.Descriptor instead.
func (*HttpRoute_Distribution_RandomAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 2, 2}
}

func (x *HttpRoute_Distribution_RandomAvailable) GetBackends() []*HttpRoute_WeightedRouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

// Retryable conditions.
type HttpRoute_Retry_Conditions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies the status code ranges that should trigger a retry.
	StatusRanges  []*HttpRoute_Retry_Conditions_StatusRange `protobuf:"bytes,1,rep,name=status_ranges,json=statusRanges,proto3" json:"status_ranges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Retry_Conditions) Reset() {
	*x = HttpRoute_Retry_Conditions{}
	mi := &file_outbound_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Retry_Conditions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Retry_Conditions) ProtoMessage() {}

func (x *HttpRoute_Retry_Conditions) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Retry_Conditions.ProtoReflect.Descriptor instead.
func (*HttpRoute_Retry_Conditions) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 3, 0}
}

func (x *HttpRoute_Retry_Conditions) GetStatusRanges() []*HttpRoute_Retry_Conditions_StatusRange {
	if x != nil {
		return x.StatusRanges
	}
	return nil
}

type HttpRoute_Retry_Conditions_StatusRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         uint32                 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End           uint32                 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRoute_Retry_Conditions_StatusRange) Reset() {
	*x = HttpRoute_Retry_Conditions_StatusRange{}
	mi := &file_outbound_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRoute_Retry_Conditions_StatusRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRoute_Retry_Conditions_StatusRange) ProtoMessage() {}

func (x *HttpRoute_Retry_Conditions_StatusRange) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRoute_Retry_Conditions_StatusRange.ProtoReflect.Descriptor instead.
func (*HttpRoute_Retry_Conditions_StatusRange) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{3, 3, 0, 0}
}

func (x *HttpRoute_Retry_Conditions_StatusRange) GetStart() uint32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *HttpRoute_Retry_Conditions_StatusRange) GetEnd() uint32 {
	if x != nil {
		return x.End
	}
	return 0
}

type GrpcRoute_Rule struct {
	state    protoimpl.MessageState       `protogen:"open.v1"`
	Matches  []*grpc_route.GrpcRouteMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	Filters  []*GrpcRoute_Filter          `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	Backends *GrpcRoute_Distribution      `protobuf:"bytes,3,opt,name=backends,proto3" json:"backends,omitempty"`
	// DEPRECATED: use `timeouts` instead. Servers should continue to set this
	// value to the same value as `timeouts.response`.
	//
	// Deprecated: Marked as deprecated in outbound.proto.
	RequestTimeout *duration.Duration   `protobuf:"bytes,4,opt,name=requestTimeout,proto3" json:"requestTimeout,omitempty"`
	Timeouts       *http_route.Timeouts `protobuf:"bytes,5,opt,name=timeouts,proto3" json:"timeouts,omitempty"`
	Retry          *GrpcRoute_Retry     `protobuf:"bytes,6,opt,name=retry,proto3" json:"retry,omitempty"`
	// If true, the proxy will allow headers to control retry and timeout
	// behavior.
	AllowL5DRequestHeaders bool `protobuf:"varint,7,opt,name=allow_l5d_request_headers,json=allowL5dRequestHeaders,proto3" json:"allow_l5d_request_headers,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *GrpcRoute_Rule) Reset() {
	*x = GrpcRoute_Rule{}
	mi := &file_outbound_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Rule) ProtoMessage() {}

func (x *GrpcRoute_Rule) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Rule.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Rule) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 0}
}

func (x *GrpcRoute_Rule) GetMatches() []*grpc_route.GrpcRouteMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *GrpcRoute_Rule) GetFilters() []*GrpcRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *GrpcRoute_Rule) GetBackends() *GrpcRoute_Distribution {
	if x != nil {
		return x.Backends
	}
	return nil
}

// Deprecated: Marked as deprecated in outbound.proto.
func (x *GrpcRoute_Rule) GetRequestTimeout() *duration.Duration {
	if x != nil {
		return x.RequestTimeout
	}
	return nil
}

func (x *GrpcRoute_Rule) GetTimeouts() *http_route.Timeouts {
	if x != nil {
		return x.Timeouts
	}
	return nil
}

func (x *GrpcRoute_Rule) GetRetry() *GrpcRoute_Retry {
	if x != nil {
		return x.Retry
	}
	return nil
}

func (x *GrpcRoute_Rule) GetAllowL5DRequestHeaders() bool {
	if x != nil {
		return x.AllowL5DRequestHeaders
	}
	return false
}

type GrpcRoute_Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*GrpcRoute_Filter_FailureInjector
	//	*GrpcRoute_Filter_RequestHeaderModifier
	Kind          isGrpcRoute_Filter_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_Filter) Reset() {
	*x = GrpcRoute_Filter{}
	mi := &file_outbound_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Filter) ProtoMessage() {}

func (x *GrpcRoute_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Filter.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Filter) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 1}
}

func (x *GrpcRoute_Filter) GetKind() isGrpcRoute_Filter_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *GrpcRoute_Filter) GetFailureInjector() *grpc_route.GrpcFailureInjector {
	if x != nil {
		if x, ok := x.Kind.(*GrpcRoute_Filter_FailureInjector); ok {
			return x.FailureInjector
		}
	}
	return nil
}

func (x *GrpcRoute_Filter) GetRequestHeaderModifier() *http_route.RequestHeaderModifier {
	if x != nil {
		if x, ok := x.Kind.(*GrpcRoute_Filter_RequestHeaderModifier); ok {
			return x.RequestHeaderModifier
		}
	}
	return nil
}

type isGrpcRoute_Filter_Kind interface {
	isGrpcRoute_Filter_Kind()
}

type GrpcRoute_Filter_FailureInjector struct {
	FailureInjector *grpc_route.GrpcFailureInjector `protobuf:"bytes,1,opt,name=failure_injector,json=failureInjector,proto3,oneof"`
}

type GrpcRoute_Filter_RequestHeaderModifier struct {
	RequestHeaderModifier *http_route.RequestHeaderModifier `protobuf:"bytes,2,opt,name=request_header_modifier,json=requestHeaderModifier,proto3,oneof"`
}

func (*GrpcRoute_Filter_FailureInjector) isGrpcRoute_Filter_Kind() {}

func (*GrpcRoute_Filter_RequestHeaderModifier) isGrpcRoute_Filter_Kind() {}

type GrpcRoute_Distribution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*GrpcRoute_Distribution_Empty_
	//	*GrpcRoute_Distribution_FirstAvailable_
	//	*GrpcRoute_Distribution_RandomAvailable_
	Kind          isGrpcRoute_Distribution_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_Distribution) Reset() {
	*x = GrpcRoute_Distribution{}
	mi := &file_outbound_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Distribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Distribution) ProtoMessage() {}

func (x *GrpcRoute_Distribution) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Distribution.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Distribution) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 2}
}

func (x *GrpcRoute_Distribution) GetKind() isGrpcRoute_Distribution_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *GrpcRoute_Distribution) GetEmpty() *GrpcRoute_Distribution_Empty {
	if x != nil {
		if x, ok := x.Kind.(*GrpcRoute_Distribution_Empty_); ok {
			return x.Empty
		}
	}
	return nil
}

func (x *GrpcRoute_Distribution) GetFirstAvailable() *GrpcRoute_Distribution_FirstAvailable {
	if x != nil {
		if x, ok := x.Kind.(*GrpcRoute_Distribution_FirstAvailable_); ok {
			return x.FirstAvailable
		}
	}
	return nil
}

func (x *GrpcRoute_Distribution) GetRandomAvailable() *GrpcRoute_Distribution_RandomAvailable {
	if x != nil {
		if x, ok := x.Kind.(*GrpcRoute_Distribution_RandomAvailable_); ok {
			return x.RandomAvailable
		}
	}
	return nil
}

type isGrpcRoute_Distribution_Kind interface {
	isGrpcRoute_Distribution_Kind()
}

type GrpcRoute_Distribution_Empty_ struct {
	Empty *GrpcRoute_Distribution_Empty `protobuf:"bytes,1,opt,name=empty,proto3,oneof"`
}

type GrpcRoute_Distribution_FirstAvailable_ struct {
	// Use the first available backend in the list.
	FirstAvailable *GrpcRoute_Distribution_FirstAvailable `protobuf:"bytes,2,opt,name=first_available,json=firstAvailable,proto3,oneof"`
}

type GrpcRoute_Distribution_RandomAvailable_ struct {
	RandomAvailable *GrpcRoute_Distribution_RandomAvailable `protobuf:"bytes,3,opt,name=random_available,json=randomAvailable,proto3,oneof"`
}

func (*GrpcRoute_Distribution_Empty_) isGrpcRoute_Distribution_Kind() {}

func (*GrpcRoute_Distribution_FirstAvailable_) isGrpcRoute_Distribution_Kind() {}

func (*GrpcRoute_Distribution_RandomAvailable_) isGrpcRoute_Distribution_Kind() {}

type GrpcRoute_Retry struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	MaxRetries      uint32                 `protobuf:"varint,1,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	MaxRequestBytes uint32                 `protobuf:"varint,2,opt,name=max_request_bytes,json=maxRequestBytes,proto3" json:"max_request_bytes,omitempty"`
	// Must be set, even if there are no internal conditions.
	Conditions    *GrpcRoute_Retry_Conditions `protobuf:"bytes,3,opt,name=conditions,proto3" json:"conditions,omitempty"`
	Timeout       *duration.Duration          `protobuf:"bytes,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Backoff       *ExponentialBackoff         `protobuf:"bytes,5,opt,name=backoff,proto3" json:"backoff,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_Retry) Reset() {
	*x = GrpcRoute_Retry{}
	mi := &file_outbound_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Retry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Retry) ProtoMessage() {}

func (x *GrpcRoute_Retry) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Retry.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Retry) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 3}
}

func (x *GrpcRoute_Retry) GetMaxRetries() uint32 {
	if x != nil {
		return x.MaxRetries
	}
	return 0
}

func (x *GrpcRoute_Retry) GetMaxRequestBytes() uint32 {
	if x != nil {
		return x.MaxRequestBytes
	}
	return 0
}

func (x *GrpcRoute_Retry) GetConditions() *GrpcRoute_Retry_Conditions {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *GrpcRoute_Retry) GetTimeout() *duration.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *GrpcRoute_Retry) GetBackoff() *ExponentialBackoff {
	if x != nil {
		return x.Backoff
	}
	return nil
}

type GrpcRoute_RouteBackend struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Backend *Backend               `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Filters []*GrpcRoute_Filter    `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	// DEPRECATED: proxies ignore this. Retry timeouts are used instead of this.
	//
	// Deprecated: Marked as deprecated in outbound.proto.
	RequestTimeout *duration.Duration `protobuf:"bytes,4,opt,name=requestTimeout,proto3" json:"requestTimeout,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GrpcRoute_RouteBackend) Reset() {
	*x = GrpcRoute_RouteBackend{}
	mi := &file_outbound_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_RouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_RouteBackend) ProtoMessage() {}

func (x *GrpcRoute_RouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_RouteBackend.ProtoReflect.Descriptor instead.
func (*GrpcRoute_RouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 4}
}

func (x *GrpcRoute_RouteBackend) GetBackend() *Backend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *GrpcRoute_RouteBackend) GetFilters() []*GrpcRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// Deprecated: Marked as deprecated in outbound.proto.
func (x *GrpcRoute_RouteBackend) GetRequestTimeout() *duration.Duration {
	if x != nil {
		return x.RequestTimeout
	}
	return nil
}

type GrpcRoute_WeightedRouteBackend struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	Backend       *GrpcRoute_RouteBackend `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Weight        uint32                  `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_WeightedRouteBackend) Reset() {
	*x = GrpcRoute_WeightedRouteBackend{}
	mi := &file_outbound_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_WeightedRouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_WeightedRouteBackend) ProtoMessage() {}

func (x *GrpcRoute_WeightedRouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_WeightedRouteBackend.ProtoReflect.Descriptor instead.
func (*GrpcRoute_WeightedRouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 5}
}

func (x *GrpcRoute_WeightedRouteBackend) GetBackend() *GrpcRoute_RouteBackend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *GrpcRoute_WeightedRouteBackend) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type GrpcRoute_Distribution_Empty struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_Distribution_Empty) Reset() {
	*x = GrpcRoute_Distribution_Empty{}
	mi := &file_outbound_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Distribution_Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Distribution_Empty) ProtoMessage() {}

func (x *GrpcRoute_Distribution_Empty) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Distribution_Empty.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Distribution_Empty) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 2, 0}
}

type GrpcRoute_Distribution_FirstAvailable struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Backends      []*GrpcRoute_RouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_Distribution_FirstAvailable) Reset() {
	*x = GrpcRoute_Distribution_FirstAvailable{}
	mi := &file_outbound_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Distribution_FirstAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Distribution_FirstAvailable) ProtoMessage() {}

func (x *GrpcRoute_Distribution_FirstAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Distribution_FirstAvailable.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Distribution_FirstAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 2, 1}
}

func (x *GrpcRoute_Distribution_FirstAvailable) GetBackends() []*GrpcRoute_RouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

type GrpcRoute_Distribution_RandomAvailable struct {
	state         protoimpl.MessageState            `protogen:"open.v1"`
	Backends      []*GrpcRoute_WeightedRouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcRoute_Distribution_RandomAvailable) Reset() {
	*x = GrpcRoute_Distribution_RandomAvailable{}
	mi := &file_outbound_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Distribution_RandomAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Distribution_RandomAvailable) ProtoMessage() {}

func (x *GrpcRoute_Distribution_RandomAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Distribution_RandomAvailable.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Distribution_RandomAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 2, 2}
}

func (x *GrpcRoute_Distribution_RandomAvailable) GetBackends() []*GrpcRoute_WeightedRouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

// Retryable gRPC status codes.
type GrpcRoute_Retry_Conditions struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Cancelled         bool                   `protobuf:"varint,1,opt,name=cancelled,proto3" json:"cancelled,omitempty"`
	DeadineExceeded   bool                   `protobuf:"varint,4,opt,name=deadine_exceeded,json=deadineExceeded,proto3" json:"deadine_exceeded,omitempty"`
	ResourceExhausted bool                   `protobuf:"varint,8,opt,name=resource_exhausted,json=resourceExhausted,proto3" json:"resource_exhausted,omitempty"`
	Internal          bool                   `protobuf:"varint,13,opt,name=internal,proto3" json:"internal,omitempty"`
	Unavailable       bool                   `protobuf:"varint,14,opt,name=unavailable,proto3" json:"unavailable,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GrpcRoute_Retry_Conditions) Reset() {
	*x = GrpcRoute_Retry_Conditions{}
	mi := &file_outbound_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcRoute_Retry_Conditions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcRoute_Retry_Conditions) ProtoMessage() {}

func (x *GrpcRoute_Retry_Conditions) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrpcRoute_Retry_Conditions.ProtoReflect.Descriptor instead.
func (*GrpcRoute_Retry_Conditions) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{4, 3, 0}
}

func (x *GrpcRoute_Retry_Conditions) GetCancelled() bool {
	if x != nil {
		return x.Cancelled
	}
	return false
}

func (x *GrpcRoute_Retry_Conditions) GetDeadineExceeded() bool {
	if x != nil {
		return x.DeadineExceeded
	}
	return false
}

func (x *GrpcRoute_Retry_Conditions) GetResourceExhausted() bool {
	if x != nil {
		return x.ResourceExhausted
	}
	return false
}

func (x *GrpcRoute_Retry_Conditions) GetInternal() bool {
	if x != nil {
		return x.Internal
	}
	return false
}

func (x *GrpcRoute_Retry_Conditions) GetUnavailable() bool {
	if x != nil {
		return x.Unavailable
	}
	return false
}

type OpaqueRoute_Rule struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Backends      *OpaqueRoute_Distribution `protobuf:"bytes,1,opt,name=backends,proto3" json:"backends,omitempty"`
	Filters       []*OpaqueRoute_Filter     `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_Rule) Reset() {
	*x = OpaqueRoute_Rule{}
	mi := &file_outbound_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_Rule) ProtoMessage() {}

func (x *OpaqueRoute_Rule) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_Rule.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_Rule) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 0}
}

func (x *OpaqueRoute_Rule) GetBackends() *OpaqueRoute_Distribution {
	if x != nil {
		return x.Backends
	}
	return nil
}

func (x *OpaqueRoute_Rule) GetFilters() []*OpaqueRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

type OpaqueRoute_Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*OpaqueRoute_Filter_Invalid
	//	*OpaqueRoute_Filter_Forbidden
	Kind          isOpaqueRoute_Filter_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_Filter) Reset() {
	*x = OpaqueRoute_Filter{}
	mi := &file_outbound_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_Filter) ProtoMessage() {}

func (x *OpaqueRoute_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_Filter.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_Filter) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 1}
}

func (x *OpaqueRoute_Filter) GetKind() isOpaqueRoute_Filter_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *OpaqueRoute_Filter) GetInvalid() *opaque_route.Invalid {
	if x != nil {
		if x, ok := x.Kind.(*OpaqueRoute_Filter_Invalid); ok {
			return x.Invalid
		}
	}
	return nil
}

func (x *OpaqueRoute_Filter) GetForbidden() *opaque_route.Forbidden {
	if x != nil {
		if x, ok := x.Kind.(*OpaqueRoute_Filter_Forbidden); ok {
			return x.Forbidden
		}
	}
	return nil
}

type isOpaqueRoute_Filter_Kind interface {
	isOpaqueRoute_Filter_Kind()
}

type OpaqueRoute_Filter_Invalid struct {
	Invalid *opaque_route.Invalid `protobuf:"bytes,1,opt,name=invalid,proto3,oneof"`
}

type OpaqueRoute_Filter_Forbidden struct {
	Forbidden *opaque_route.Forbidden `protobuf:"bytes,2,opt,name=forbidden,proto3,oneof"`
}

func (*OpaqueRoute_Filter_Invalid) isOpaqueRoute_Filter_Kind() {}

func (*OpaqueRoute_Filter_Forbidden) isOpaqueRoute_Filter_Kind() {}

type OpaqueRoute_Distribution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*OpaqueRoute_Distribution_Empty_
	//	*OpaqueRoute_Distribution_FirstAvailable_
	//	*OpaqueRoute_Distribution_RandomAvailable_
	Kind          isOpaqueRoute_Distribution_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_Distribution) Reset() {
	*x = OpaqueRoute_Distribution{}
	mi := &file_outbound_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_Distribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_Distribution) ProtoMessage() {}

func (x *OpaqueRoute_Distribution) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_Distribution.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_Distribution) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 2}
}

func (x *OpaqueRoute_Distribution) GetKind() isOpaqueRoute_Distribution_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *OpaqueRoute_Distribution) GetEmpty() *OpaqueRoute_Distribution_Empty {
	if x != nil {
		if x, ok := x.Kind.(*OpaqueRoute_Distribution_Empty_); ok {
			return x.Empty
		}
	}
	return nil
}

func (x *OpaqueRoute_Distribution) GetFirstAvailable() *OpaqueRoute_Distribution_FirstAvailable {
	if x != nil {
		if x, ok := x.Kind.(*OpaqueRoute_Distribution_FirstAvailable_); ok {
			return x.FirstAvailable
		}
	}
	return nil
}

func (x *OpaqueRoute_Distribution) GetRandomAvailable() *OpaqueRoute_Distribution_RandomAvailable {
	if x != nil {
		if x, ok := x.Kind.(*OpaqueRoute_Distribution_RandomAvailable_); ok {
			return x.RandomAvailable
		}
	}
	return nil
}

type isOpaqueRoute_Distribution_Kind interface {
	isOpaqueRoute_Distribution_Kind()
}

type OpaqueRoute_Distribution_Empty_ struct {
	Empty *OpaqueRoute_Distribution_Empty `protobuf:"bytes,1,opt,name=empty,proto3,oneof"`
}

type OpaqueRoute_Distribution_FirstAvailable_ struct {
	// Use the first available backend in the list.
	FirstAvailable *OpaqueRoute_Distribution_FirstAvailable `protobuf:"bytes,2,opt,name=first_available,json=firstAvailable,proto3,oneof"`
}

type OpaqueRoute_Distribution_RandomAvailable_ struct {
	RandomAvailable *OpaqueRoute_Distribution_RandomAvailable `protobuf:"bytes,3,opt,name=random_available,json=randomAvailable,proto3,oneof"`
}

func (*OpaqueRoute_Distribution_Empty_) isOpaqueRoute_Distribution_Kind() {}

func (*OpaqueRoute_Distribution_FirstAvailable_) isOpaqueRoute_Distribution_Kind() {}

func (*OpaqueRoute_Distribution_RandomAvailable_) isOpaqueRoute_Distribution_Kind() {}

type OpaqueRoute_RouteBackend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *Backend               `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Filters       []*OpaqueRoute_Filter  `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_RouteBackend) Reset() {
	*x = OpaqueRoute_RouteBackend{}
	mi := &file_outbound_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_RouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_RouteBackend) ProtoMessage() {}

func (x *OpaqueRoute_RouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_RouteBackend.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_RouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 3}
}

func (x *OpaqueRoute_RouteBackend) GetBackend() *Backend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *OpaqueRoute_RouteBackend) GetFilters() []*OpaqueRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

type OpaqueRoute_WeightedRouteBackend struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Backend       *OpaqueRoute_RouteBackend `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Weight        uint32                    `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_WeightedRouteBackend) Reset() {
	*x = OpaqueRoute_WeightedRouteBackend{}
	mi := &file_outbound_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_WeightedRouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_WeightedRouteBackend) ProtoMessage() {}

func (x *OpaqueRoute_WeightedRouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_WeightedRouteBackend.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_WeightedRouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 4}
}

func (x *OpaqueRoute_WeightedRouteBackend) GetBackend() *OpaqueRoute_RouteBackend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *OpaqueRoute_WeightedRouteBackend) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type OpaqueRoute_Distribution_Empty struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_Distribution_Empty) Reset() {
	*x = OpaqueRoute_Distribution_Empty{}
	mi := &file_outbound_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_Distribution_Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_Distribution_Empty) ProtoMessage() {}

func (x *OpaqueRoute_Distribution_Empty) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_Distribution_Empty.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_Distribution_Empty) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 2, 0}
}

type OpaqueRoute_Distribution_FirstAvailable struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	Backends      []*OpaqueRoute_RouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_Distribution_FirstAvailable) Reset() {
	*x = OpaqueRoute_Distribution_FirstAvailable{}
	mi := &file_outbound_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_Distribution_FirstAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_Distribution_FirstAvailable) ProtoMessage() {}

func (x *OpaqueRoute_Distribution_FirstAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_Distribution_FirstAvailable.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_Distribution_FirstAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 2, 1}
}

func (x *OpaqueRoute_Distribution_FirstAvailable) GetBackends() []*OpaqueRoute_RouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

type OpaqueRoute_Distribution_RandomAvailable struct {
	state         protoimpl.MessageState              `protogen:"open.v1"`
	Backends      []*OpaqueRoute_WeightedRouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpaqueRoute_Distribution_RandomAvailable) Reset() {
	*x = OpaqueRoute_Distribution_RandomAvailable{}
	mi := &file_outbound_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpaqueRoute_Distribution_RandomAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpaqueRoute_Distribution_RandomAvailable) ProtoMessage() {}

func (x *OpaqueRoute_Distribution_RandomAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpaqueRoute_Distribution_RandomAvailable.ProtoReflect.Descriptor instead.
func (*OpaqueRoute_Distribution_RandomAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{5, 2, 2}
}

func (x *OpaqueRoute_Distribution_RandomAvailable) GetBackends() []*OpaqueRoute_WeightedRouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

type TlsRoute_Rule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backends      *TlsRoute_Distribution `protobuf:"bytes,1,opt,name=backends,proto3" json:"backends,omitempty"`
	Filters       []*TlsRoute_Filter     `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_Rule) Reset() {
	*x = TlsRoute_Rule{}
	mi := &file_outbound_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_Rule) ProtoMessage() {}

func (x *TlsRoute_Rule) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_Rule.ProtoReflect.Descriptor instead.
func (*TlsRoute_Rule) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 0}
}

func (x *TlsRoute_Rule) GetBackends() *TlsRoute_Distribution {
	if x != nil {
		return x.Backends
	}
	return nil
}

func (x *TlsRoute_Rule) GetFilters() []*TlsRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

type TlsRoute_Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*TlsRoute_Filter_Invalid
	//	*TlsRoute_Filter_Forbidden
	Kind          isTlsRoute_Filter_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_Filter) Reset() {
	*x = TlsRoute_Filter{}
	mi := &file_outbound_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_Filter) ProtoMessage() {}

func (x *TlsRoute_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_Filter.ProtoReflect.Descriptor instead.
func (*TlsRoute_Filter) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 1}
}

func (x *TlsRoute_Filter) GetKind() isTlsRoute_Filter_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *TlsRoute_Filter) GetInvalid() *opaque_route.Invalid {
	if x != nil {
		if x, ok := x.Kind.(*TlsRoute_Filter_Invalid); ok {
			return x.Invalid
		}
	}
	return nil
}

func (x *TlsRoute_Filter) GetForbidden() *opaque_route.Forbidden {
	if x != nil {
		if x, ok := x.Kind.(*TlsRoute_Filter_Forbidden); ok {
			return x.Forbidden
		}
	}
	return nil
}

type isTlsRoute_Filter_Kind interface {
	isTlsRoute_Filter_Kind()
}

type TlsRoute_Filter_Invalid struct {
	Invalid *opaque_route.Invalid `protobuf:"bytes,1,opt,name=invalid,proto3,oneof"`
}

type TlsRoute_Filter_Forbidden struct {
	Forbidden *opaque_route.Forbidden `protobuf:"bytes,2,opt,name=forbidden,proto3,oneof"`
}

func (*TlsRoute_Filter_Invalid) isTlsRoute_Filter_Kind() {}

func (*TlsRoute_Filter_Forbidden) isTlsRoute_Filter_Kind() {}

type TlsRoute_Distribution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*TlsRoute_Distribution_Empty_
	//	*TlsRoute_Distribution_FirstAvailable_
	//	*TlsRoute_Distribution_RandomAvailable_
	Kind          isTlsRoute_Distribution_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_Distribution) Reset() {
	*x = TlsRoute_Distribution{}
	mi := &file_outbound_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_Distribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_Distribution) ProtoMessage() {}

func (x *TlsRoute_Distribution) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_Distribution.ProtoReflect.Descriptor instead.
func (*TlsRoute_Distribution) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 2}
}

func (x *TlsRoute_Distribution) GetKind() isTlsRoute_Distribution_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *TlsRoute_Distribution) GetEmpty() *TlsRoute_Distribution_Empty {
	if x != nil {
		if x, ok := x.Kind.(*TlsRoute_Distribution_Empty_); ok {
			return x.Empty
		}
	}
	return nil
}

func (x *TlsRoute_Distribution) GetFirstAvailable() *TlsRoute_Distribution_FirstAvailable {
	if x != nil {
		if x, ok := x.Kind.(*TlsRoute_Distribution_FirstAvailable_); ok {
			return x.FirstAvailable
		}
	}
	return nil
}

func (x *TlsRoute_Distribution) GetRandomAvailable() *TlsRoute_Distribution_RandomAvailable {
	if x != nil {
		if x, ok := x.Kind.(*TlsRoute_Distribution_RandomAvailable_); ok {
			return x.RandomAvailable
		}
	}
	return nil
}

type isTlsRoute_Distribution_Kind interface {
	isTlsRoute_Distribution_Kind()
}

type TlsRoute_Distribution_Empty_ struct {
	Empty *TlsRoute_Distribution_Empty `protobuf:"bytes,1,opt,name=empty,proto3,oneof"`
}

type TlsRoute_Distribution_FirstAvailable_ struct {
	// Use the first available backend in the list.
	FirstAvailable *TlsRoute_Distribution_FirstAvailable `protobuf:"bytes,2,opt,name=first_available,json=firstAvailable,proto3,oneof"`
}

type TlsRoute_Distribution_RandomAvailable_ struct {
	RandomAvailable *TlsRoute_Distribution_RandomAvailable `protobuf:"bytes,3,opt,name=random_available,json=randomAvailable,proto3,oneof"`
}

func (*TlsRoute_Distribution_Empty_) isTlsRoute_Distribution_Kind() {}

func (*TlsRoute_Distribution_FirstAvailable_) isTlsRoute_Distribution_Kind() {}

func (*TlsRoute_Distribution_RandomAvailable_) isTlsRoute_Distribution_Kind() {}

type TlsRoute_RouteBackend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *Backend               `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Filters       []*TlsRoute_Filter     `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_RouteBackend) Reset() {
	*x = TlsRoute_RouteBackend{}
	mi := &file_outbound_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_RouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_RouteBackend) ProtoMessage() {}

func (x *TlsRoute_RouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_RouteBackend.ProtoReflect.Descriptor instead.
func (*TlsRoute_RouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 3}
}

func (x *TlsRoute_RouteBackend) GetBackend() *Backend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *TlsRoute_RouteBackend) GetFilters() []*TlsRoute_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

type TlsRoute_WeightedRouteBackend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *TlsRoute_RouteBackend `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Weight        uint32                 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_WeightedRouteBackend) Reset() {
	*x = TlsRoute_WeightedRouteBackend{}
	mi := &file_outbound_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_WeightedRouteBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_WeightedRouteBackend) ProtoMessage() {}

func (x *TlsRoute_WeightedRouteBackend) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_WeightedRouteBackend.ProtoReflect.Descriptor instead.
func (*TlsRoute_WeightedRouteBackend) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 4}
}

func (x *TlsRoute_WeightedRouteBackend) GetBackend() *TlsRoute_RouteBackend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *TlsRoute_WeightedRouteBackend) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type TlsRoute_Distribution_Empty struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_Distribution_Empty) Reset() {
	*x = TlsRoute_Distribution_Empty{}
	mi := &file_outbound_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_Distribution_Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_Distribution_Empty) ProtoMessage() {}

func (x *TlsRoute_Distribution_Empty) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_Distribution_Empty.ProtoReflect.Descriptor instead.
func (*TlsRoute_Distribution_Empty) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 2, 0}
}

type TlsRoute_Distribution_FirstAvailable struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Backends      []*TlsRoute_RouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_Distribution_FirstAvailable) Reset() {
	*x = TlsRoute_Distribution_FirstAvailable{}
	mi := &file_outbound_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_Distribution_FirstAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_Distribution_FirstAvailable) ProtoMessage() {}

func (x *TlsRoute_Distribution_FirstAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_Distribution_FirstAvailable.ProtoReflect.Descriptor instead.
func (*TlsRoute_Distribution_FirstAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 2, 1}
}

func (x *TlsRoute_Distribution_FirstAvailable) GetBackends() []*TlsRoute_RouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

type TlsRoute_Distribution_RandomAvailable struct {
	state         protoimpl.MessageState           `protogen:"open.v1"`
	Backends      []*TlsRoute_WeightedRouteBackend `protobuf:"bytes,1,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TlsRoute_Distribution_RandomAvailable) Reset() {
	*x = TlsRoute_Distribution_RandomAvailable{}
	mi := &file_outbound_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsRoute_Distribution_RandomAvailable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsRoute_Distribution_RandomAvailable) ProtoMessage() {}

func (x *TlsRoute_Distribution_RandomAvailable) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsRoute_Distribution_RandomAvailable.ProtoReflect.Descriptor instead.
func (*TlsRoute_Distribution_RandomAvailable) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{6, 2, 2}
}

func (x *TlsRoute_Distribution_RandomAvailable) GetBackends() []*TlsRoute_WeightedRouteBackend {
	if x != nil {
		return x.Backends
	}
	return nil
}

// A strategy for discovering endpoints for a service.
type Backend_EndpointDiscovery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*Backend_EndpointDiscovery_Dst
	Kind          isBackend_EndpointDiscovery_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_EndpointDiscovery) Reset() {
	*x = Backend_EndpointDiscovery{}
	mi := &file_outbound_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_EndpointDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_EndpointDiscovery) ProtoMessage() {}

func (x *Backend_EndpointDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_EndpointDiscovery.ProtoReflect.Descriptor instead.
func (*Backend_EndpointDiscovery) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{7, 0}
}

func (x *Backend_EndpointDiscovery) GetKind() isBackend_EndpointDiscovery_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *Backend_EndpointDiscovery) GetDst() *Backend_EndpointDiscovery_DestinationGet {
	if x != nil {
		if x, ok := x.Kind.(*Backend_EndpointDiscovery_Dst); ok {
			return x.Dst
		}
	}
	return nil
}

type isBackend_EndpointDiscovery_Kind interface {
	isBackend_EndpointDiscovery_Kind()
}

type Backend_EndpointDiscovery_Dst struct {
	// Use the `Destination` service to discover endpoints for this service.
	Dst *Backend_EndpointDiscovery_DestinationGet `protobuf:"bytes,1,opt,name=dst,proto3,oneof"`
}

func (*Backend_EndpointDiscovery_Dst) isBackend_EndpointDiscovery_Kind() {}

// Describes a power-of-two-choices (P2C) load balancer configuration for a
// backend.
type Backend_BalanceP2C struct {
	state     protoimpl.MessageState     `protogen:"open.v1"`
	Discovery *Backend_EndpointDiscovery `protobuf:"bytes,1,opt,name=discovery,proto3" json:"discovery,omitempty"`
	// The load estimation strategy used by this load balancer.
	//
	// Types that are valid to be assigned to Load:
	//
	//	*Backend_BalanceP2C_PeakEwma_
	Load          isBackend_BalanceP2C_Load `protobuf_oneof:"load"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_BalanceP2C) Reset() {
	*x = Backend_BalanceP2C{}
	mi := &file_outbound_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_BalanceP2C) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_BalanceP2C) ProtoMessage() {}

func (x *Backend_BalanceP2C) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_BalanceP2C.ProtoReflect.Descriptor instead.
func (*Backend_BalanceP2C) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{7, 1}
}

func (x *Backend_BalanceP2C) GetDiscovery() *Backend_EndpointDiscovery {
	if x != nil {
		return x.Discovery
	}
	return nil
}

func (x *Backend_BalanceP2C) GetLoad() isBackend_BalanceP2C_Load {
	if x != nil {
		return x.Load
	}
	return nil
}

func (x *Backend_BalanceP2C) GetPeakEwma() *Backend_BalanceP2C_PeakEwma {
	if x != nil {
		if x, ok := x.Load.(*Backend_BalanceP2C_PeakEwma_); ok {
			return x.PeakEwma
		}
	}
	return nil
}

type isBackend_BalanceP2C_Load interface {
	isBackend_BalanceP2C_Load()
}

type Backend_BalanceP2C_PeakEwma_ struct {
	// This load balancer uses peak EWMA (exponentially weighted moving
	// average) load estimates.
	PeakEwma *Backend_BalanceP2C_PeakEwma `protobuf:"bytes,2,opt,name=peak_ewma,json=peakEwma,proto3,oneof"`
}

func (*Backend_BalanceP2C_PeakEwma_) isBackend_BalanceP2C_Load() {}

type Backend_EndpointDiscovery_DestinationGet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_EndpointDiscovery_DestinationGet) Reset() {
	*x = Backend_EndpointDiscovery_DestinationGet{}
	mi := &file_outbound_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_EndpointDiscovery_DestinationGet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_EndpointDiscovery_DestinationGet) ProtoMessage() {}

func (x *Backend_EndpointDiscovery_DestinationGet) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_EndpointDiscovery_DestinationGet.ProtoReflect.Descriptor instead.
func (*Backend_EndpointDiscovery_DestinationGet) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{7, 0, 0}
}

func (x *Backend_EndpointDiscovery_DestinationGet) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// Parameters configuring peak EWMA load estimation.
type Backend_BalanceP2C_PeakEwma struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Initial latency value used when no latencies have been
	// recorded for an endpoint.
	DefaultRtt *duration.Duration `protobuf:"bytes,1,opt,name=default_rtt,json=defaultRtt,proto3" json:"default_rtt,omitempty"`
	// The duration of the moving window over which latency is observed.
	Decay         *duration.Duration `protobuf:"bytes,2,opt,name=decay,proto3" json:"decay,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_BalanceP2C_PeakEwma) Reset() {
	*x = Backend_BalanceP2C_PeakEwma{}
	mi := &file_outbound_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_BalanceP2C_PeakEwma) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_BalanceP2C_PeakEwma) ProtoMessage() {}

func (x *Backend_BalanceP2C_PeakEwma) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_BalanceP2C_PeakEwma.ProtoReflect.Descriptor instead.
func (*Backend_BalanceP2C_PeakEwma) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{7, 1, 0}
}

func (x *Backend_BalanceP2C_PeakEwma) GetDefaultRtt() *duration.Duration {
	if x != nil {
		return x.DefaultRtt
	}
	return nil
}

func (x *Backend_BalanceP2C_PeakEwma) GetDecay() *duration.Duration {
	if x != nil {
		return x.Decay
	}
	return nil
}

type FailureAccrual_ConsecutiveFailures struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MaxFailures   uint32                 `protobuf:"varint,1,opt,name=max_failures,json=maxFailures,proto3" json:"max_failures,omitempty"`
	Backoff       *ExponentialBackoff    `protobuf:"bytes,2,opt,name=backoff,proto3" json:"backoff,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FailureAccrual_ConsecutiveFailures) Reset() {
	*x = FailureAccrual_ConsecutiveFailures{}
	mi := &file_outbound_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FailureAccrual_ConsecutiveFailures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FailureAccrual_ConsecutiveFailures) ProtoMessage() {}

func (x *FailureAccrual_ConsecutiveFailures) ProtoReflect() protoreflect.Message {
	mi := &file_outbound_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FailureAccrual_ConsecutiveFailures.ProtoReflect.Descriptor instead.
func (*FailureAccrual_ConsecutiveFailures) Descriptor() ([]byte, []int) {
	return file_outbound_proto_rawDescGZIP(), []int{9, 0}
}

func (x *FailureAccrual_ConsecutiveFailures) GetMaxFailures() uint32 {
	if x != nil {
		return x.MaxFailures
	}
	return 0
}

func (x *FailureAccrual_ConsecutiveFailures) GetBackoff() *ExponentialBackoff {
	if x != nil {
		return x.Backoff
	}
	return nil
}

var File_outbound_proto protoreflect.FileDescriptor

const file_outbound_proto_rawDesc = "" +
	"\n" +
	"\x0eoutbound.proto\x12\x19io.linkerd.proxy.outbound\x1a\tnet.proto\x1a\x11destination.proto\x1a\n" +
	"meta.proto\x1a\x10grpc_route.proto\x1a\x12opaque_route.proto\x1a\x0ftls_route.proto\x1a\x10http_route.proto\x1a\x1egoogle/protobuf/duration.proto\"\x98\x01\n" +
	"\vTrafficSpec\x12'\n" +
	"\x0fsource_workload\x18\x01 \x01(\tR\x0esourceWorkload\x126\n" +
	"\x04addr\x18\x02 \x01(\v2 .io.linkerd.proxy.net.TcpAddressH\x00R\x04addr\x12\x1e\n" +
	"\tauthority\x18\x03 \x01(\tH\x00R\tauthorityB\b\n" +
	"\x06target\"\x93\x01\n" +
	"\x0eOutboundPolicy\x12D\n" +
	"\bprotocol\x18\x01 \x01(\v2(.io.linkerd.proxy.outbound.ProxyProtocolR\bprotocol\x12;\n" +
	"\bmetadata\x18\x02 \x01(\v2\x1f.io.linkerd.proxy.meta.MetadataR\bmetadata\"\xba\n" +
	"\n" +
	"\rProxyProtocol\x12I\n" +
	"\x06detect\x18\x01 \x01(\v2/.io.linkerd.proxy.outbound.ProxyProtocol.DetectH\x00R\x06detect\x12I\n" +
	"\x06opaque\x18\x02 \x01(\v2/.io.linkerd.proxy.outbound.ProxyProtocol.OpaqueH\x00R\x06opaque\x12F\n" +
	"\x05http1\x18\x03 \x01(\v2..io.linkerd.proxy.outbound.ProxyProtocol.Http1H\x00R\x05http1\x12F\n" +
	"\x05http2\x18\x04 \x01(\v2..io.linkerd.proxy.outbound.ProxyProtocol.Http2H\x00R\x05http2\x12C\n" +
	"\x04grpc\x18\x05 \x01(\v2-.io.linkerd.proxy.outbound.ProxyProtocol.GrpcH\x00R\x04grpc\x12@\n" +
	"\x03tls\x18\x06 \x01(\v2,.io.linkerd.proxy.outbound.ProxyProtocol.TlsH\x00R\x03tls\x1a\x92\x02\n" +
	"\x06Detect\x123\n" +
	"\atimeout\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12G\n" +
	"\x06opaque\x18\x02 \x01(\v2/.io.linkerd.proxy.outbound.ProxyProtocol.OpaqueR\x06opaque\x12D\n" +
	"\x05http1\x18\x03 \x01(\v2..io.linkerd.proxy.outbound.ProxyProtocol.Http1R\x05http1\x12D\n" +
	"\x05http2\x18\x04 \x01(\v2..io.linkerd.proxy.outbound.ProxyProtocol.Http2R\x05http2\x1aH\n" +
	"\x06Opaque\x12>\n" +
	"\x06routes\x18\x01 \x03(\v2&.io.linkerd.proxy.outbound.OpaqueRouteR\x06routes\x1a\x99\x01\n" +
	"\x05Http1\x12<\n" +
	"\x06routes\x18\x01 \x03(\v2$.io.linkerd.proxy.outbound.HttpRouteR\x06routes\x12R\n" +
	"\x0ffailure_accrual\x18\x02 \x01(\v2).io.linkerd.proxy.outbound.FailureAccrualR\x0efailureAccrual\x1a\x99\x01\n" +
	"\x05Http2\x12<\n" +
	"\x06routes\x18\x01 \x03(\v2$.io.linkerd.proxy.outbound.HttpRouteR\x06routes\x12R\n" +
	"\x0ffailure_accrual\x18\x02 \x01(\v2).io.linkerd.proxy.outbound.FailureAccrualR\x0efailureAccrual\x1a\x98\x01\n" +
	"\x04Grpc\x12<\n" +
	"\x06routes\x18\x01 \x03(\v2$.io.linkerd.proxy.outbound.GrpcRouteR\x06routes\x12R\n" +
	"\x0ffailure_accrual\x18\x02 \x01(\v2).io.linkerd.proxy.outbound.FailureAccrualR\x0efailureAccrual\x1aB\n" +
	"\x03Tls\x12;\n" +
	"\x06routes\x18\x01 \x03(\v2#.io.linkerd.proxy.outbound.TlsRouteR\x06routesB\x06\n" +
	"\x04kind\"\xa0\x13\n" +
	"\tHttpRoute\x12;\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1f.io.linkerd.proxy.meta.MetadataR\bmetadata\x12<\n" +
	"\x05hosts\x18\x02 \x03(\v2&.io.linkerd.proxy.http_route.HostMatchR\x05hosts\x12?\n" +
	"\x05rules\x18\x03 \x03(\v2).io.linkerd.proxy.outbound.HttpRoute.RuleR\x05rules\x1a\xea\x03\n" +
	"\x04Rule\x12E\n" +
	"\amatches\x18\x01 \x03(\v2+.io.linkerd.proxy.http_route.HttpRouteMatchR\amatches\x12E\n" +
	"\afilters\x18\x02 \x03(\v2+.io.linkerd.proxy.outbound.HttpRoute.FilterR\afilters\x12M\n" +
	"\bbackends\x18\x03 \x01(\v21.io.linkerd.proxy.outbound.HttpRoute.DistributionR\bbackends\x12E\n" +
	"\x0erequestTimeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationB\x02\x18\x01R\x0erequestTimeout\x12A\n" +
	"\btimeouts\x18\x05 \x01(\v2%.io.linkerd.proxy.http_route.TimeoutsR\btimeouts\x12@\n" +
	"\x05retry\x18\x06 \x01(\v2*.io.linkerd.proxy.outbound.HttpRoute.RetryR\x05retry\x129\n" +
	"\x19allow_l5d_request_headers\x18\a \x01(\bR\x16allowL5dRequestHeaders\x1a\x9a\x03\n" +
	"\x06Filter\x12]\n" +
	"\x10failure_injector\x18\x01 \x01(\v20.io.linkerd.proxy.http_route.HttpFailureInjectorH\x00R\x0ffailureInjector\x12l\n" +
	"\x17request_header_modifier\x18\x02 \x01(\v22.io.linkerd.proxy.http_route.RequestHeaderModifierH\x00R\x15requestHeaderModifier\x12J\n" +
	"\bredirect\x18\x03 \x01(\v2,.io.linkerd.proxy.http_route.RequestRedirectH\x00R\bredirect\x12o\n" +
	"\x18response_header_modifier\x18\x04 \x01(\v23.io.linkerd.proxy.http_route.ResponseHeaderModifierH\x00R\x16responseHeaderModifierB\x06\n" +
	"\x04kind\x1a\x98\x04\n" +
	"\fDistribution\x12O\n" +
	"\x05empty\x18\x01 \x01(\v27.io.linkerd.proxy.outbound.HttpRoute.Distribution.EmptyH\x00R\x05empty\x12k\n" +
	"\x0ffirst_available\x18\x02 \x01(\v2@.io.linkerd.proxy.outbound.HttpRoute.Distribution.FirstAvailableH\x00R\x0efirstAvailable\x12n\n" +
	"\x10random_available\x18\x03 \x01(\v2A.io.linkerd.proxy.outbound.HttpRoute.Distribution.RandomAvailableH\x00R\x0frandomAvailable\x1a\a\n" +
	"\x05Empty\x1a_\n" +
	"\x0eFirstAvailable\x12M\n" +
	"\bbackends\x18\x01 \x03(\v21.io.linkerd.proxy.outbound.HttpRoute.RouteBackendR\bbackends\x1ah\n" +
	"\x0fRandomAvailable\x12U\n" +
	"\bbackends\x18\x01 \x03(\v29.io.linkerd.proxy.outbound.HttpRoute.WeightedRouteBackendR\bbackendsB\x06\n" +
	"\x04kind\x1a\xd7\x03\n" +
	"\x05Retry\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\rR\n" +
	"maxRetries\x12*\n" +
	"\x11max_request_bytes\x18\x02 \x01(\rR\x0fmaxRequestBytes\x12U\n" +
	"\n" +
	"conditions\x18\x03 \x01(\v25.io.linkerd.proxy.outbound.HttpRoute.Retry.ConditionsR\n" +
	"conditions\x123\n" +
	"\atimeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12G\n" +
	"\abackoff\x18\x05 \x01(\v2-.io.linkerd.proxy.outbound.ExponentialBackoffR\abackoff\x1a\xab\x01\n" +
	"\n" +
	"Conditions\x12f\n" +
	"\rstatus_ranges\x18\x01 \x03(\v2A.io.linkerd.proxy.outbound.HttpRoute.Retry.Conditions.StatusRangeR\fstatusRanges\x1a5\n" +
	"\vStatusRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\rR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\rR\x03end\x1a\xda\x01\n" +
	"\fRouteBackend\x12<\n" +
	"\abackend\x18\x01 \x01(\v2\".io.linkerd.proxy.outbound.BackendR\abackend\x12E\n" +
	"\afilters\x18\x03 \x03(\v2+.io.linkerd.proxy.outbound.HttpRoute.FilterR\afilters\x12E\n" +
	"\x0erequestTimeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationB\x02\x18\x01R\x0erequestTimeout\x1a{\n" +
	"\x14WeightedRouteBackend\x12K\n" +
	"\abackend\x18\x01 \x01(\v21.io.linkerd.proxy.outbound.HttpRoute.RouteBackendR\abackend\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\rR\x06weight\"\xfa\x11\n" +
	"\tGrpcRoute\x12;\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1f.io.linkerd.proxy.meta.MetadataR\bmetadata\x12<\n" +
	"\x05hosts\x18\x02 \x03(\v2&.io.linkerd.proxy.http_route.HostMatchR\x05hosts\x12?\n" +
	"\x05rules\x18\x03 \x03(\v2).io.linkerd.proxy.outbound.GrpcRoute.RuleR\x05rules\x1a\xea\x03\n" +
	"\x04Rule\x12E\n" +
	"\amatches\x18\x01 \x03(\v2+.io.linkerd.proxy.grpc_route.GrpcRouteMatchR\amatches\x12E\n" +
	"\afilters\x18\x02 \x03(\v2+.io.linkerd.proxy.outbound.GrpcRoute.FilterR\afilters\x12M\n" +
	"\bbackends\x18\x03 \x01(\v21.io.linkerd.proxy.outbound.GrpcRoute.DistributionR\bbackends\x12E\n" +
	"\x0erequestTimeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationB\x02\x18\x01R\x0erequestTimeout\x12A\n" +
	"\btimeouts\x18\x05 \x01(\v2%.io.linkerd.proxy.http_route.TimeoutsR\btimeouts\x12@\n" +
	"\x05retry\x18\x06 \x01(\v2*.io.linkerd.proxy.outbound.GrpcRoute.RetryR\x05retry\x129\n" +
	"\x19allow_l5d_request_headers\x18\a \x01(\bR\x16allowL5dRequestHeaders\x1a\xdd\x01\n" +
	"\x06Filter\x12]\n" +
	"\x10failure_injector\x18\x01 \x01(\v20.io.linkerd.proxy.grpc_route.GrpcFailureInjectorH\x00R\x0ffailureInjector\x12l\n" +
	"\x17request_header_modifier\x18\x02 \x01(\v22.io.linkerd.proxy.http_route.RequestHeaderModifierH\x00R\x15requestHeaderModifierB\x06\n" +
	"\x04kind\x1a\x98\x04\n" +
	"\fDistribution\x12O\n" +
	"\x05empty\x18\x01 \x01(\v27.io.linkerd.proxy.outbound.GrpcRoute.Distribution.EmptyH\x00R\x05empty\x12k\n" +
	"\x0ffirst_available\x18\x02 \x01(\v2@.io.linkerd.proxy.outbound.GrpcRoute.Distribution.FirstAvailableH\x00R\x0efirstAvailable\x12n\n" +
	"\x10random_available\x18\x03 \x01(\v2A.io.linkerd.proxy.outbound.GrpcRoute.Distribution.RandomAvailableH\x00R\x0frandomAvailable\x1a\a\n" +
	"\x05Empty\x1a_\n" +
	"\x0eFirstAvailable\x12M\n" +
	"\bbackends\x18\x01 \x03(\v21.io.linkerd.proxy.outbound.GrpcRoute.RouteBackendR\bbackends\x1ah\n" +
	"\x0fRandomAvailable\x12U\n" +
	"\bbackends\x18\x01 \x03(\v29.io.linkerd.proxy.outbound.GrpcRoute.WeightedRouteBackendR\bbackendsB\x06\n" +
	"\x04kind\x1a\xee\x03\n" +
	"\x05Retry\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\rR\n" +
	"maxRetries\x12*\n" +
	"\x11max_request_bytes\x18\x02 \x01(\rR\x0fmaxRequestBytes\x12U\n" +
	"\n" +
	"conditions\x18\x03 \x01(\v25.io.linkerd.proxy.outbound.GrpcRoute.Retry.ConditionsR\n" +
	"conditions\x123\n" +
	"\atimeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12G\n" +
	"\abackoff\x18\x05 \x01(\v2-.io.linkerd.proxy.outbound.ExponentialBackoffR\abackoff\x1a\xc2\x01\n" +
	"\n" +
	"Conditions\x12\x1c\n" +
	"\tcancelled\x18\x01 \x01(\bR\tcancelled\x12)\n" +
	"\x10deadine_exceeded\x18\x04 \x01(\bR\x0fdeadineExceeded\x12-\n" +
	"\x12resource_exhausted\x18\b \x01(\bR\x11resourceExhausted\x12\x1a\n" +
	"\binternal\x18\r \x01(\bR\binternal\x12 \n" +
	"\vunavailable\x18\x0e \x01(\bR\vunavailable\x1a\xda\x01\n" +
	"\fRouteBackend\x12<\n" +
	"\abackend\x18\x01 \x01(\v2\".io.linkerd.proxy.outbound.BackendR\abackend\x12E\n" +
	"\afilters\x18\x03 \x03(\v2+.io.linkerd.proxy.outbound.GrpcRoute.FilterR\afilters\x12E\n" +
	"\x0erequestTimeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationB\x02\x18\x01R\x0erequestTimeout\x1a{\n" +
	"\x14WeightedRouteBackend\x12K\n" +
	"\abackend\x18\x01 \x01(\v21.io.linkerd.proxy.outbound.GrpcRoute.RouteBackendR\abackend\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\rR\x06weight\"\x99\n" +
	"\n" +
	"\vOpaqueRoute\x12;\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1f.io.linkerd.proxy.meta.MetadataR\bmetadata\x12A\n" +
	"\x05rules\x18\x03 \x03(\v2+.io.linkerd.proxy.outbound.OpaqueRoute.RuleR\x05rules\x1a\xa0\x01\n" +
	"\x04Rule\x12O\n" +
	"\bbackends\x18\x01 \x01(\v23.io.linkerd.proxy.outbound.OpaqueRoute.DistributionR\bbackends\x12G\n" +
	"\afilters\x18\x02 \x03(\v2-.io.linkerd.proxy.outbound.OpaqueRoute.FilterR\afilters\x1a\x9e\x01\n" +
	"\x06Filter\x12B\n" +
	"\ainvalid\x18\x01 \x01(\v2&.io.linkerd.proxy.opaque_route.InvalidH\x00R\ainvalid\x12H\n" +
	"\tforbidden\x18\x02 \x01(\v2(.io.linkerd.proxy.opaque_route.ForbiddenH\x00R\tforbiddenB\x06\n" +
	"\x04kind\x1a\xa2\x04\n" +
	"\fDistribution\x12Q\n" +
	"\x05empty\x18\x01 \x01(\v29.io.linkerd.proxy.outbound.OpaqueRoute.Distribution.EmptyH\x00R\x05empty\x12m\n" +
	"\x0ffirst_available\x18\x02 \x01(\v2B.io.linkerd.proxy.outbound.OpaqueRoute.Distribution.FirstAvailableH\x00R\x0efirstAvailable\x12p\n" +
	"\x10random_available\x18\x03 \x01(\v2C.io.linkerd.proxy.outbound.OpaqueRoute.Distribution.RandomAvailableH\x00R\x0frandomAvailable\x1a\a\n" +
	"\x05Empty\x1aa\n" +
	"\x0eFirstAvailable\x12O\n" +
	"\bbackends\x18\x01 \x03(\v23.io.linkerd.proxy.outbound.OpaqueRoute.RouteBackendR\bbackends\x1aj\n" +
	"\x0fRandomAvailable\x12W\n" +
	"\bbackends\x18\x01 \x03(\v2;.io.linkerd.proxy.outbound.OpaqueRoute.WeightedRouteBackendR\bbackendsB\x06\n" +
	"\x04kind\x1a\x9b\x01\n" +
	"\fRouteBackend\x12<\n" +
	"\abackend\x18\x01 \x01(\v2\".io.linkerd.proxy.outbound.BackendR\abackend\x12G\n" +
	"\afilters\x18\x03 \x03(\v2-.io.linkerd.proxy.outbound.OpaqueRoute.FilterR\afiltersJ\x04\b\x02\x10\x03\x1a}\n" +
	"\x14WeightedRouteBackend\x12M\n" +
	"\abackend\x18\x01 \x01(\v23.io.linkerd.proxy.outbound.OpaqueRoute.RouteBackendR\abackend\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\rR\x06weightJ\x04\b\x04\x10\x05\"\xb2\n" +
	"\n" +
	"\bTlsRoute\x12;\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1f.io.linkerd.proxy.meta.MetadataR\bmetadata\x128\n" +
	"\x04snis\x18\x02 \x03(\v2$.io.linkerd.proxy.tls_route.SniMatchR\x04snis\x12>\n" +
	"\x05rules\x18\x03 \x03(\v2(.io.linkerd.proxy.outbound.TlsRoute.RuleR\x05rules\x1a\x9a\x01\n" +
	"\x04Rule\x12L\n" +
	"\bbackends\x18\x01 \x01(\v20.io.linkerd.proxy.outbound.TlsRoute.DistributionR\bbackends\x12D\n" +
	"\afilters\x18\x02 \x03(\v2*.io.linkerd.proxy.outbound.TlsRoute.FilterR\afilters\x1a\x9e\x01\n" +
	"\x06Filter\x12B\n" +
	"\ainvalid\x18\x01 \x01(\v2&.io.linkerd.proxy.opaque_route.InvalidH\x00R\ainvalid\x12H\n" +
	"\tforbidden\x18\x02 \x01(\v2(.io.linkerd.proxy.opaque_route.ForbiddenH\x00R\tforbiddenB\x06\n" +
	"\x04kind\x1a\x93\x04\n" +
	"\fDistribution\x12N\n" +
	"\x05empty\x18\x01 \x01(\v26.io.linkerd.proxy.outbound.TlsRoute.Distribution.EmptyH\x00R\x05empty\x12j\n" +
	"\x0ffirst_available\x18\x02 \x01(\v2?.io.linkerd.proxy.outbound.TlsRoute.Distribution.FirstAvailableH\x00R\x0efirstAvailable\x12m\n" +
	"\x10random_available\x18\x03 \x01(\v2@.io.linkerd.proxy.outbound.TlsRoute.Distribution.RandomAvailableH\x00R\x0frandomAvailable\x1a\a\n" +
	"\x05Empty\x1a^\n" +
	"\x0eFirstAvailable\x12L\n" +
	"\bbackends\x18\x01 \x03(\v20.io.linkerd.proxy.outbound.TlsRoute.RouteBackendR\bbackends\x1ag\n" +
	"\x0fRandomAvailable\x12T\n" +
	"\bbackends\x18\x01 \x03(\v28.io.linkerd.proxy.outbound.TlsRoute.WeightedRouteBackendR\bbackendsB\x06\n" +
	"\x04kind\x1a\x98\x01\n" +
	"\fRouteBackend\x12<\n" +
	"\abackend\x18\x01 \x01(\v2\".io.linkerd.proxy.outbound.BackendR\abackend\x12D\n" +
	"\afilters\x18\x03 \x03(\v2*.io.linkerd.proxy.outbound.TlsRoute.FilterR\afiltersJ\x04\b\x02\x10\x03\x1az\n" +
	"\x14WeightedRouteBackend\x12J\n" +
	"\abackend\x18\x01 \x01(\v20.io.linkerd.proxy.outbound.TlsRoute.RouteBackendR\abackend\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\rR\x06weightJ\x04\b\x04\x10\x05\"\xf3\x05\n" +
	"\aBackend\x12;\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1f.io.linkerd.proxy.meta.MetadataR\bmetadata\x12F\n" +
	"\aforward\x18\x02 \x01(\v2*.io.linkerd.proxy.destination.WeightedAddrH\x00R\aforward\x12K\n" +
	"\bbalancer\x18\x03 \x01(\v2-.io.linkerd.proxy.outbound.Backend.BalanceP2cH\x00R\bbalancer\x126\n" +
	"\x05queue\x18\x04 \x01(\v2 .io.linkerd.proxy.outbound.QueueR\x05queue\x1a\x9a\x01\n" +
	"\x11EndpointDiscovery\x12W\n" +
	"\x03dst\x18\x01 \x01(\v2C.io.linkerd.proxy.outbound.Backend.EndpointDiscovery.DestinationGetH\x00R\x03dst\x1a$\n" +
	"\x0eDestinationGet\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04pathB\x06\n" +
	"\x04kind\x1a\xb8\x02\n" +
	"\n" +
	"BalanceP2c\x12R\n" +
	"\tdiscovery\x18\x01 \x01(\v24.io.linkerd.proxy.outbound.Backend.EndpointDiscoveryR\tdiscovery\x12U\n" +
	"\tpeak_ewma\x18\x02 \x01(\v26.io.linkerd.proxy.outbound.Backend.BalanceP2c.PeakEwmaH\x00R\bpeakEwma\x1aw\n" +
	"\bPeakEwma\x12:\n" +
	"\vdefault_rtt\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"defaultRtt\x12/\n" +
	"\x05decay\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x05decayB\x06\n" +
	"\x04loadB\x06\n" +
	"\x04kind\"i\n" +
	"\x05Queue\x12\x1a\n" +
	"\bcapacity\x18\x01 \x01(\rR\bcapacity\x12D\n" +
	"\x10failfast_timeout\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x0ffailfastTimeout\"\x90\x02\n" +
	"\x0eFailureAccrual\x12r\n" +
	"\x14consecutive_failures\x18\x01 \x01(\v2=.io.linkerd.proxy.outbound.FailureAccrual.ConsecutiveFailuresH\x00R\x13consecutiveFailures\x1a\x81\x01\n" +
	"\x13ConsecutiveFailures\x12!\n" +
	"\fmax_failures\x18\x01 \x01(\rR\vmaxFailures\x12G\n" +
	"\abackoff\x18\x02 \x01(\v2-.io.linkerd.proxy.outbound.ExponentialBackoffR\abackoffB\x06\n" +
	"\x04kind\"\xaf\x01\n" +
	"\x12ExponentialBackoff\x12:\n" +
	"\vmin_backoff\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"minBackoff\x12:\n" +
	"\vmax_backoff\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"maxBackoff\x12!\n" +
	"\fjitter_ratio\x18\x03 \x01(\x02R\vjitterRatio2\xce\x01\n" +
	"\x10OutboundPolicies\x12Z\n" +
	"\x03Get\x12&.io.linkerd.proxy.outbound.TrafficSpec\x1a).io.linkerd.proxy.outbound.OutboundPolicy\"\x00\x12^\n" +
	"\x05Watch\x12&.io.linkerd.proxy.outbound.TrafficSpec\x1a).io.linkerd.proxy.outbound.OutboundPolicy\"\x000\x01B3Z1github.com/linkerd/linkerd2-proxy-api/go/outboundb\x06proto3"

var (
	file_outbound_proto_rawDescOnce sync.Once
	file_outbound_proto_rawDescData []byte
)

func file_outbound_proto_rawDescGZIP() []byte {
	file_outbound_proto_rawDescOnce.Do(func() {
		file_outbound_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_outbound_proto_rawDesc), len(file_outbound_proto_rawDesc)))
	})
	return file_outbound_proto_rawDescData
}

var file_outbound_proto_msgTypes = make([]protoimpl.MessageInfo, 59)
var file_outbound_proto_goTypes = []any{
	(*TrafficSpec)(nil),                              // 0: io.linkerd.proxy.outbound.TrafficSpec
	(*OutboundPolicy)(nil),                           // 1: io.linkerd.proxy.outbound.OutboundPolicy
	(*ProxyProtocol)(nil),                            // 2: io.linkerd.proxy.outbound.ProxyProtocol
	(*HttpRoute)(nil),                                // 3: io.linkerd.proxy.outbound.HttpRoute
	(*GrpcRoute)(nil),                                // 4: io.linkerd.proxy.outbound.GrpcRoute
	(*OpaqueRoute)(nil),                              // 5: io.linkerd.proxy.outbound.OpaqueRoute
	(*TlsRoute)(nil),                                 // 6: io.linkerd.proxy.outbound.TlsRoute
	(*Backend)(nil),                                  // 7: io.linkerd.proxy.outbound.Backend
	(*Queue)(nil),                                    // 8: io.linkerd.proxy.outbound.Queue
	(*FailureAccrual)(nil),                           // 9: io.linkerd.proxy.outbound.FailureAccrual
	(*ExponentialBackoff)(nil),                       // 10: io.linkerd.proxy.outbound.ExponentialBackoff
	(*ProxyProtocol_Detect)(nil),                     // 11: io.linkerd.proxy.outbound.ProxyProtocol.Detect
	(*ProxyProtocol_Opaque)(nil),                     // 12: io.linkerd.proxy.outbound.ProxyProtocol.Opaque
	(*ProxyProtocol_Http1)(nil),                      // 13: io.linkerd.proxy.outbound.ProxyProtocol.Http1
	(*ProxyProtocol_Http2)(nil),                      // 14: io.linkerd.proxy.outbound.ProxyProtocol.Http2
	(*ProxyProtocol_Grpc)(nil),                       // 15: io.linkerd.proxy.outbound.ProxyProtocol.Grpc
	(*ProxyProtocol_Tls)(nil),                        // 16: io.linkerd.proxy.outbound.ProxyProtocol.Tls
	(*HttpRoute_Rule)(nil),                           // 17: io.linkerd.proxy.outbound.HttpRoute.Rule
	(*HttpRoute_Filter)(nil),                         // 18: io.linkerd.proxy.outbound.HttpRoute.Filter
	(*HttpRoute_Distribution)(nil),                   // 19: io.linkerd.proxy.outbound.HttpRoute.Distribution
	(*HttpRoute_Retry)(nil),                          // 20: io.linkerd.proxy.outbound.HttpRoute.Retry
	(*HttpRoute_RouteBackend)(nil),                   // 21: io.linkerd.proxy.outbound.HttpRoute.RouteBackend
	(*HttpRoute_WeightedRouteBackend)(nil),           // 22: io.linkerd.proxy.outbound.HttpRoute.WeightedRouteBackend
	(*HttpRoute_Distribution_Empty)(nil),             // 23: io.linkerd.proxy.outbound.HttpRoute.Distribution.Empty
	(*HttpRoute_Distribution_FirstAvailable)(nil),    // 24: io.linkerd.proxy.outbound.HttpRoute.Distribution.FirstAvailable
	(*HttpRoute_Distribution_RandomAvailable)(nil),   // 25: io.linkerd.proxy.outbound.HttpRoute.Distribution.RandomAvailable
	(*HttpRoute_Retry_Conditions)(nil),               // 26: io.linkerd.proxy.outbound.HttpRoute.Retry.Conditions
	(*HttpRoute_Retry_Conditions_StatusRange)(nil),   // 27: io.linkerd.proxy.outbound.HttpRoute.Retry.Conditions.StatusRange
	(*GrpcRoute_Rule)(nil),                           // 28: io.linkerd.proxy.outbound.GrpcRoute.Rule
	(*GrpcRoute_Filter)(nil),                         // 29: io.linkerd.proxy.outbound.GrpcRoute.Filter
	(*GrpcRoute_Distribution)(nil),                   // 30: io.linkerd.proxy.outbound.GrpcRoute.Distribution
	(*GrpcRoute_Retry)(nil),                          // 31: io.linkerd.proxy.outbound.GrpcRoute.Retry
	(*GrpcRoute_RouteBackend)(nil),                   // 32: io.linkerd.proxy.outbound.GrpcRoute.RouteBackend
	(*GrpcRoute_WeightedRouteBackend)(nil),           // 33: io.linkerd.proxy.outbound.GrpcRoute.WeightedRouteBackend
	(*GrpcRoute_Distribution_Empty)(nil),             // 34: io.linkerd.proxy.outbound.GrpcRoute.Distribution.Empty
	(*GrpcRoute_Distribution_FirstAvailable)(nil),    // 35: io.linkerd.proxy.outbound.GrpcRoute.Distribution.FirstAvailable
	(*GrpcRoute_Distribution_RandomAvailable)(nil),   // 36: io.linkerd.proxy.outbound.GrpcRoute.Distribution.RandomAvailable
	(*GrpcRoute_Retry_Conditions)(nil),               // 37: io.linkerd.proxy.outbound.GrpcRoute.Retry.Conditions
	(*OpaqueRoute_Rule)(nil),                         // 38: io.linkerd.proxy.outbound.OpaqueRoute.Rule
	(*OpaqueRoute_Filter)(nil),                       // 39: io.linkerd.proxy.outbound.OpaqueRoute.Filter
	(*OpaqueRoute_Distribution)(nil),                 // 40: io.linkerd.proxy.outbound.OpaqueRoute.Distribution
	(*OpaqueRoute_RouteBackend)(nil),                 // 41: io.linkerd.proxy.outbound.OpaqueRoute.RouteBackend
	(*OpaqueRoute_WeightedRouteBackend)(nil),         // 42: io.linkerd.proxy.outbound.OpaqueRoute.WeightedRouteBackend
	(*OpaqueRoute_Distribution_Empty)(nil),           // 43: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.Empty
	(*OpaqueRoute_Distribution_FirstAvailable)(nil),  // 44: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.FirstAvailable
	(*OpaqueRoute_Distribution_RandomAvailable)(nil), // 45: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.RandomAvailable
	(*TlsRoute_Rule)(nil),                            // 46: io.linkerd.proxy.outbound.TlsRoute.Rule
	(*TlsRoute_Filter)(nil),                          // 47: io.linkerd.proxy.outbound.TlsRoute.Filter
	(*TlsRoute_Distribution)(nil),                    // 48: io.linkerd.proxy.outbound.TlsRoute.Distribution
	(*TlsRoute_RouteBackend)(nil),                    // 49: io.linkerd.proxy.outbound.TlsRoute.RouteBackend
	(*TlsRoute_WeightedRouteBackend)(nil),            // 50: io.linkerd.proxy.outbound.TlsRoute.WeightedRouteBackend
	(*TlsRoute_Distribution_Empty)(nil),              // 51: io.linkerd.proxy.outbound.TlsRoute.Distribution.Empty
	(*TlsRoute_Distribution_FirstAvailable)(nil),     // 52: io.linkerd.proxy.outbound.TlsRoute.Distribution.FirstAvailable
	(*TlsRoute_Distribution_RandomAvailable)(nil),    // 53: io.linkerd.proxy.outbound.TlsRoute.Distribution.RandomAvailable
	(*Backend_EndpointDiscovery)(nil),                // 54: io.linkerd.proxy.outbound.Backend.EndpointDiscovery
	(*Backend_BalanceP2C)(nil),                       // 55: io.linkerd.proxy.outbound.Backend.BalanceP2c
	(*Backend_EndpointDiscovery_DestinationGet)(nil), // 56: io.linkerd.proxy.outbound.Backend.EndpointDiscovery.DestinationGet
	(*Backend_BalanceP2C_PeakEwma)(nil),              // 57: io.linkerd.proxy.outbound.Backend.BalanceP2c.PeakEwma
	(*FailureAccrual_ConsecutiveFailures)(nil),       // 58: io.linkerd.proxy.outbound.FailureAccrual.ConsecutiveFailures
	(*net.TcpAddress)(nil),                           // 59: io.linkerd.proxy.net.TcpAddress
	(*meta.Metadata)(nil),                            // 60: io.linkerd.proxy.meta.Metadata
	(*http_route.HostMatch)(nil),                     // 61: io.linkerd.proxy.http_route.HostMatch
	(*tls_route.SniMatch)(nil),                       // 62: io.linkerd.proxy.tls_route.SniMatch
	(*destination.WeightedAddr)(nil),                 // 63: io.linkerd.proxy.destination.WeightedAddr
	(*duration.Duration)(nil),                        // 64: google.protobuf.Duration
	(*http_route.HttpRouteMatch)(nil),                // 65: io.linkerd.proxy.http_route.HttpRouteMatch
	(*http_route.Timeouts)(nil),                      // 66: io.linkerd.proxy.http_route.Timeouts
	(*http_route.HttpFailureInjector)(nil),           // 67: io.linkerd.proxy.http_route.HttpFailureInjector
	(*http_route.RequestHeaderModifier)(nil),         // 68: io.linkerd.proxy.http_route.RequestHeaderModifier
	(*http_route.RequestRedirect)(nil),               // 69: io.linkerd.proxy.http_route.RequestRedirect
	(*http_route.ResponseHeaderModifier)(nil),        // 70: io.linkerd.proxy.http_route.ResponseHeaderModifier
	(*grpc_route.GrpcRouteMatch)(nil),                // 71: io.linkerd.proxy.grpc_route.GrpcRouteMatch
	(*grpc_route.GrpcFailureInjector)(nil),           // 72: io.linkerd.proxy.grpc_route.GrpcFailureInjector
	(*opaque_route.Invalid)(nil),                     // 73: io.linkerd.proxy.opaque_route.Invalid
	(*opaque_route.Forbidden)(nil),                   // 74: io.linkerd.proxy.opaque_route.Forbidden
}
var file_outbound_proto_depIdxs = []int32{
	59,  // 0: io.linkerd.proxy.outbound.TrafficSpec.addr:type_name -> io.linkerd.proxy.net.TcpAddress
	2,   // 1: io.linkerd.proxy.outbound.OutboundPolicy.protocol:type_name -> io.linkerd.proxy.outbound.ProxyProtocol
	60,  // 2: io.linkerd.proxy.outbound.OutboundPolicy.metadata:type_name -> io.linkerd.proxy.meta.Metadata
	11,  // 3: io.linkerd.proxy.outbound.ProxyProtocol.detect:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Detect
	12,  // 4: io.linkerd.proxy.outbound.ProxyProtocol.opaque:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Opaque
	13,  // 5: io.linkerd.proxy.outbound.ProxyProtocol.http1:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Http1
	14,  // 6: io.linkerd.proxy.outbound.ProxyProtocol.http2:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Http2
	15,  // 7: io.linkerd.proxy.outbound.ProxyProtocol.grpc:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Grpc
	16,  // 8: io.linkerd.proxy.outbound.ProxyProtocol.tls:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Tls
	60,  // 9: io.linkerd.proxy.outbound.HttpRoute.metadata:type_name -> io.linkerd.proxy.meta.Metadata
	61,  // 10: io.linkerd.proxy.outbound.HttpRoute.hosts:type_name -> io.linkerd.proxy.http_route.HostMatch
	17,  // 11: io.linkerd.proxy.outbound.HttpRoute.rules:type_name -> io.linkerd.proxy.outbound.HttpRoute.Rule
	60,  // 12: io.linkerd.proxy.outbound.GrpcRoute.metadata:type_name -> io.linkerd.proxy.meta.Metadata
	61,  // 13: io.linkerd.proxy.outbound.GrpcRoute.hosts:type_name -> io.linkerd.proxy.http_route.HostMatch
	28,  // 14: io.linkerd.proxy.outbound.GrpcRoute.rules:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Rule
	60,  // 15: io.linkerd.proxy.outbound.OpaqueRoute.metadata:type_name -> io.linkerd.proxy.meta.Metadata
	38,  // 16: io.linkerd.proxy.outbound.OpaqueRoute.rules:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Rule
	60,  // 17: io.linkerd.proxy.outbound.TlsRoute.metadata:type_name -> io.linkerd.proxy.meta.Metadata
	62,  // 18: io.linkerd.proxy.outbound.TlsRoute.snis:type_name -> io.linkerd.proxy.tls_route.SniMatch
	46,  // 19: io.linkerd.proxy.outbound.TlsRoute.rules:type_name -> io.linkerd.proxy.outbound.TlsRoute.Rule
	60,  // 20: io.linkerd.proxy.outbound.Backend.metadata:type_name -> io.linkerd.proxy.meta.Metadata
	63,  // 21: io.linkerd.proxy.outbound.Backend.forward:type_name -> io.linkerd.proxy.destination.WeightedAddr
	55,  // 22: io.linkerd.proxy.outbound.Backend.balancer:type_name -> io.linkerd.proxy.outbound.Backend.BalanceP2c
	8,   // 23: io.linkerd.proxy.outbound.Backend.queue:type_name -> io.linkerd.proxy.outbound.Queue
	64,  // 24: io.linkerd.proxy.outbound.Queue.failfast_timeout:type_name -> google.protobuf.Duration
	58,  // 25: io.linkerd.proxy.outbound.FailureAccrual.consecutive_failures:type_name -> io.linkerd.proxy.outbound.FailureAccrual.ConsecutiveFailures
	64,  // 26: io.linkerd.proxy.outbound.ExponentialBackoff.min_backoff:type_name -> google.protobuf.Duration
	64,  // 27: io.linkerd.proxy.outbound.ExponentialBackoff.max_backoff:type_name -> google.protobuf.Duration
	64,  // 28: io.linkerd.proxy.outbound.ProxyProtocol.Detect.timeout:type_name -> google.protobuf.Duration
	12,  // 29: io.linkerd.proxy.outbound.ProxyProtocol.Detect.opaque:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Opaque
	13,  // 30: io.linkerd.proxy.outbound.ProxyProtocol.Detect.http1:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Http1
	14,  // 31: io.linkerd.proxy.outbound.ProxyProtocol.Detect.http2:type_name -> io.linkerd.proxy.outbound.ProxyProtocol.Http2
	5,   // 32: io.linkerd.proxy.outbound.ProxyProtocol.Opaque.routes:type_name -> io.linkerd.proxy.outbound.OpaqueRoute
	3,   // 33: io.linkerd.proxy.outbound.ProxyProtocol.Http1.routes:type_name -> io.linkerd.proxy.outbound.HttpRoute
	9,   // 34: io.linkerd.proxy.outbound.ProxyProtocol.Http1.failure_accrual:type_name -> io.linkerd.proxy.outbound.FailureAccrual
	3,   // 35: io.linkerd.proxy.outbound.ProxyProtocol.Http2.routes:type_name -> io.linkerd.proxy.outbound.HttpRoute
	9,   // 36: io.linkerd.proxy.outbound.ProxyProtocol.Http2.failure_accrual:type_name -> io.linkerd.proxy.outbound.FailureAccrual
	4,   // 37: io.linkerd.proxy.outbound.ProxyProtocol.Grpc.routes:type_name -> io.linkerd.proxy.outbound.GrpcRoute
	9,   // 38: io.linkerd.proxy.outbound.ProxyProtocol.Grpc.failure_accrual:type_name -> io.linkerd.proxy.outbound.FailureAccrual
	6,   // 39: io.linkerd.proxy.outbound.ProxyProtocol.Tls.routes:type_name -> io.linkerd.proxy.outbound.TlsRoute
	65,  // 40: io.linkerd.proxy.outbound.HttpRoute.Rule.matches:type_name -> io.linkerd.proxy.http_route.HttpRouteMatch
	18,  // 41: io.linkerd.proxy.outbound.HttpRoute.Rule.filters:type_name -> io.linkerd.proxy.outbound.HttpRoute.Filter
	19,  // 42: io.linkerd.proxy.outbound.HttpRoute.Rule.backends:type_name -> io.linkerd.proxy.outbound.HttpRoute.Distribution
	64,  // 43: io.linkerd.proxy.outbound.HttpRoute.Rule.requestTimeout:type_name -> google.protobuf.Duration
	66,  // 44: io.linkerd.proxy.outbound.HttpRoute.Rule.timeouts:type_name -> io.linkerd.proxy.http_route.Timeouts
	20,  // 45: io.linkerd.proxy.outbound.HttpRoute.Rule.retry:type_name -> io.linkerd.proxy.outbound.HttpRoute.Retry
	67,  // 46: io.linkerd.proxy.outbound.HttpRoute.Filter.failure_injector:type_name -> io.linkerd.proxy.http_route.HttpFailureInjector
	68,  // 47: io.linkerd.proxy.outbound.HttpRoute.Filter.request_header_modifier:type_name -> io.linkerd.proxy.http_route.RequestHeaderModifier
	69,  // 48: io.linkerd.proxy.outbound.HttpRoute.Filter.redirect:type_name -> io.linkerd.proxy.http_route.RequestRedirect
	70,  // 49: io.linkerd.proxy.outbound.HttpRoute.Filter.response_header_modifier:type_name -> io.linkerd.proxy.http_route.ResponseHeaderModifier
	23,  // 50: io.linkerd.proxy.outbound.HttpRoute.Distribution.empty:type_name -> io.linkerd.proxy.outbound.HttpRoute.Distribution.Empty
	24,  // 51: io.linkerd.proxy.outbound.HttpRoute.Distribution.first_available:type_name -> io.linkerd.proxy.outbound.HttpRoute.Distribution.FirstAvailable
	25,  // 52: io.linkerd.proxy.outbound.HttpRoute.Distribution.random_available:type_name -> io.linkerd.proxy.outbound.HttpRoute.Distribution.RandomAvailable
	26,  // 53: io.linkerd.proxy.outbound.HttpRoute.Retry.conditions:type_name -> io.linkerd.proxy.outbound.HttpRoute.Retry.Conditions
	64,  // 54: io.linkerd.proxy.outbound.HttpRoute.Retry.timeout:type_name -> google.protobuf.Duration
	10,  // 55: io.linkerd.proxy.outbound.HttpRoute.Retry.backoff:type_name -> io.linkerd.proxy.outbound.ExponentialBackoff
	7,   // 56: io.linkerd.proxy.outbound.HttpRoute.RouteBackend.backend:type_name -> io.linkerd.proxy.outbound.Backend
	18,  // 57: io.linkerd.proxy.outbound.HttpRoute.RouteBackend.filters:type_name -> io.linkerd.proxy.outbound.HttpRoute.Filter
	64,  // 58: io.linkerd.proxy.outbound.HttpRoute.RouteBackend.requestTimeout:type_name -> google.protobuf.Duration
	21,  // 59: io.linkerd.proxy.outbound.HttpRoute.WeightedRouteBackend.backend:type_name -> io.linkerd.proxy.outbound.HttpRoute.RouteBackend
	21,  // 60: io.linkerd.proxy.outbound.HttpRoute.Distribution.FirstAvailable.backends:type_name -> io.linkerd.proxy.outbound.HttpRoute.RouteBackend
	22,  // 61: io.linkerd.proxy.outbound.HttpRoute.Distribution.RandomAvailable.backends:type_name -> io.linkerd.proxy.outbound.HttpRoute.WeightedRouteBackend
	27,  // 62: io.linkerd.proxy.outbound.HttpRoute.Retry.Conditions.status_ranges:type_name -> io.linkerd.proxy.outbound.HttpRoute.Retry.Conditions.StatusRange
	71,  // 63: io.linkerd.proxy.outbound.GrpcRoute.Rule.matches:type_name -> io.linkerd.proxy.grpc_route.GrpcRouteMatch
	29,  // 64: io.linkerd.proxy.outbound.GrpcRoute.Rule.filters:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Filter
	30,  // 65: io.linkerd.proxy.outbound.GrpcRoute.Rule.backends:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Distribution
	64,  // 66: io.linkerd.proxy.outbound.GrpcRoute.Rule.requestTimeout:type_name -> google.protobuf.Duration
	66,  // 67: io.linkerd.proxy.outbound.GrpcRoute.Rule.timeouts:type_name -> io.linkerd.proxy.http_route.Timeouts
	31,  // 68: io.linkerd.proxy.outbound.GrpcRoute.Rule.retry:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Retry
	72,  // 69: io.linkerd.proxy.outbound.GrpcRoute.Filter.failure_injector:type_name -> io.linkerd.proxy.grpc_route.GrpcFailureInjector
	68,  // 70: io.linkerd.proxy.outbound.GrpcRoute.Filter.request_header_modifier:type_name -> io.linkerd.proxy.http_route.RequestHeaderModifier
	34,  // 71: io.linkerd.proxy.outbound.GrpcRoute.Distribution.empty:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Distribution.Empty
	35,  // 72: io.linkerd.proxy.outbound.GrpcRoute.Distribution.first_available:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Distribution.FirstAvailable
	36,  // 73: io.linkerd.proxy.outbound.GrpcRoute.Distribution.random_available:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Distribution.RandomAvailable
	37,  // 74: io.linkerd.proxy.outbound.GrpcRoute.Retry.conditions:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Retry.Conditions
	64,  // 75: io.linkerd.proxy.outbound.GrpcRoute.Retry.timeout:type_name -> google.protobuf.Duration
	10,  // 76: io.linkerd.proxy.outbound.GrpcRoute.Retry.backoff:type_name -> io.linkerd.proxy.outbound.ExponentialBackoff
	7,   // 77: io.linkerd.proxy.outbound.GrpcRoute.RouteBackend.backend:type_name -> io.linkerd.proxy.outbound.Backend
	29,  // 78: io.linkerd.proxy.outbound.GrpcRoute.RouteBackend.filters:type_name -> io.linkerd.proxy.outbound.GrpcRoute.Filter
	64,  // 79: io.linkerd.proxy.outbound.GrpcRoute.RouteBackend.requestTimeout:type_name -> google.protobuf.Duration
	32,  // 80: io.linkerd.proxy.outbound.GrpcRoute.WeightedRouteBackend.backend:type_name -> io.linkerd.proxy.outbound.GrpcRoute.RouteBackend
	32,  // 81: io.linkerd.proxy.outbound.GrpcRoute.Distribution.FirstAvailable.backends:type_name -> io.linkerd.proxy.outbound.GrpcRoute.RouteBackend
	33,  // 82: io.linkerd.proxy.outbound.GrpcRoute.Distribution.RandomAvailable.backends:type_name -> io.linkerd.proxy.outbound.GrpcRoute.WeightedRouteBackend
	40,  // 83: io.linkerd.proxy.outbound.OpaqueRoute.Rule.backends:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Distribution
	39,  // 84: io.linkerd.proxy.outbound.OpaqueRoute.Rule.filters:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Filter
	73,  // 85: io.linkerd.proxy.outbound.OpaqueRoute.Filter.invalid:type_name -> io.linkerd.proxy.opaque_route.Invalid
	74,  // 86: io.linkerd.proxy.outbound.OpaqueRoute.Filter.forbidden:type_name -> io.linkerd.proxy.opaque_route.Forbidden
	43,  // 87: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.empty:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Distribution.Empty
	44,  // 88: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.first_available:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Distribution.FirstAvailable
	45,  // 89: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.random_available:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Distribution.RandomAvailable
	7,   // 90: io.linkerd.proxy.outbound.OpaqueRoute.RouteBackend.backend:type_name -> io.linkerd.proxy.outbound.Backend
	39,  // 91: io.linkerd.proxy.outbound.OpaqueRoute.RouteBackend.filters:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.Filter
	41,  // 92: io.linkerd.proxy.outbound.OpaqueRoute.WeightedRouteBackend.backend:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.RouteBackend
	41,  // 93: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.FirstAvailable.backends:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.RouteBackend
	42,  // 94: io.linkerd.proxy.outbound.OpaqueRoute.Distribution.RandomAvailable.backends:type_name -> io.linkerd.proxy.outbound.OpaqueRoute.WeightedRouteBackend
	48,  // 95: io.linkerd.proxy.outbound.TlsRoute.Rule.backends:type_name -> io.linkerd.proxy.outbound.TlsRoute.Distribution
	47,  // 96: io.linkerd.proxy.outbound.TlsRoute.Rule.filters:type_name -> io.linkerd.proxy.outbound.TlsRoute.Filter
	73,  // 97: io.linkerd.proxy.outbound.TlsRoute.Filter.invalid:type_name -> io.linkerd.proxy.opaque_route.Invalid
	74,  // 98: io.linkerd.proxy.outbound.TlsRoute.Filter.forbidden:type_name -> io.linkerd.proxy.opaque_route.Forbidden
	51,  // 99: io.linkerd.proxy.outbound.TlsRoute.Distribution.empty:type_name -> io.linkerd.proxy.outbound.TlsRoute.Distribution.Empty
	52,  // 100: io.linkerd.proxy.outbound.TlsRoute.Distribution.first_available:type_name -> io.linkerd.proxy.outbound.TlsRoute.Distribution.FirstAvailable
	53,  // 101: io.linkerd.proxy.outbound.TlsRoute.Distribution.random_available:type_name -> io.linkerd.proxy.outbound.TlsRoute.Distribution.RandomAvailable
	7,   // 102: io.linkerd.proxy.outbound.TlsRoute.RouteBackend.backend:type_name -> io.linkerd.proxy.outbound.Backend
	47,  // 103: io.linkerd.proxy.outbound.TlsRoute.RouteBackend.filters:type_name -> io.linkerd.proxy.outbound.TlsRoute.Filter
	49,  // 104: io.linkerd.proxy.outbound.TlsRoute.WeightedRouteBackend.backend:type_name -> io.linkerd.proxy.outbound.TlsRoute.RouteBackend
	49,  // 105: io.linkerd.proxy.outbound.TlsRoute.Distribution.FirstAvailable.backends:type_name -> io.linkerd.proxy.outbound.TlsRoute.RouteBackend
	50,  // 106: io.linkerd.proxy.outbound.TlsRoute.Distribution.RandomAvailable.backends:type_name -> io.linkerd.proxy.outbound.TlsRoute.WeightedRouteBackend
	56,  // 107: io.linkerd.proxy.outbound.Backend.EndpointDiscovery.dst:type_name -> io.linkerd.proxy.outbound.Backend.EndpointDiscovery.DestinationGet
	54,  // 108: io.linkerd.proxy.outbound.Backend.BalanceP2c.discovery:type_name -> io.linkerd.proxy.outbound.Backend.EndpointDiscovery
	57,  // 109: io.linkerd.proxy.outbound.Backend.BalanceP2c.peak_ewma:type_name -> io.linkerd.proxy.outbound.Backend.BalanceP2c.PeakEwma
	64,  // 110: io.linkerd.proxy.outbound.Backend.BalanceP2c.PeakEwma.default_rtt:type_name -> google.protobuf.Duration
	64,  // 111: io.linkerd.proxy.outbound.Backend.BalanceP2c.PeakEwma.decay:type_name -> google.protobuf.Duration
	10,  // 112: io.linkerd.proxy.outbound.FailureAccrual.ConsecutiveFailures.backoff:type_name -> io.linkerd.proxy.outbound.ExponentialBackoff
	0,   // 113: io.linkerd.proxy.outbound.OutboundPolicies.Get:input_type -> io.linkerd.proxy.outbound.TrafficSpec
	0,   // 114: io.linkerd.proxy.outbound.OutboundPolicies.Watch:input_type -> io.linkerd.proxy.outbound.TrafficSpec
	1,   // 115: io.linkerd.proxy.outbound.OutboundPolicies.Get:output_type -> io.linkerd.proxy.outbound.OutboundPolicy
	1,   // 116: io.linkerd.proxy.outbound.OutboundPolicies.Watch:output_type -> io.linkerd.proxy.outbound.OutboundPolicy
	115, // [115:117] is the sub-list for method output_type
	113, // [113:115] is the sub-list for method input_type
	113, // [113:113] is the sub-list for extension type_name
	113, // [113:113] is the sub-list for extension extendee
	0,   // [0:113] is the sub-list for field type_name
}

func init() { file_outbound_proto_init() }
func file_outbound_proto_init() {
	if File_outbound_proto != nil {
		return
	}
	file_outbound_proto_msgTypes[0].OneofWrappers = []any{
		(*TrafficSpec_Addr)(nil),
		(*TrafficSpec_Authority)(nil),
	}
	file_outbound_proto_msgTypes[2].OneofWrappers = []any{
		(*ProxyProtocol_Detect_)(nil),
		(*ProxyProtocol_Opaque_)(nil),
		(*ProxyProtocol_Http1_)(nil),
		(*ProxyProtocol_Http2_)(nil),
		(*ProxyProtocol_Grpc_)(nil),
		(*ProxyProtocol_Tls_)(nil),
	}
	file_outbound_proto_msgTypes[7].OneofWrappers = []any{
		(*Backend_Forward)(nil),
		(*Backend_Balancer)(nil),
	}
	file_outbound_proto_msgTypes[9].OneofWrappers = []any{
		(*FailureAccrual_ConsecutiveFailures_)(nil),
	}
	file_outbound_proto_msgTypes[18].OneofWrappers = []any{
		(*HttpRoute_Filter_FailureInjector)(nil),
		(*HttpRoute_Filter_RequestHeaderModifier)(nil),
		(*HttpRoute_Filter_Redirect)(nil),
		(*HttpRoute_Filter_ResponseHeaderModifier)(nil),
	}
	file_outbound_proto_msgTypes[19].OneofWrappers = []any{
		(*HttpRoute_Distribution_Empty_)(nil),
		(*HttpRoute_Distribution_FirstAvailable_)(nil),
		(*HttpRoute_Distribution_RandomAvailable_)(nil),
	}
	file_outbound_proto_msgTypes[29].OneofWrappers = []any{
		(*GrpcRoute_Filter_FailureInjector)(nil),
		(*GrpcRoute_Filter_RequestHeaderModifier)(nil),
	}
	file_outbound_proto_msgTypes[30].OneofWrappers = []any{
		(*GrpcRoute_Distribution_Empty_)(nil),
		(*GrpcRoute_Distribution_FirstAvailable_)(nil),
		(*GrpcRoute_Distribution_RandomAvailable_)(nil),
	}
	file_outbound_proto_msgTypes[39].OneofWrappers = []any{
		(*OpaqueRoute_Filter_Invalid)(nil),
		(*OpaqueRoute_Filter_Forbidden)(nil),
	}
	file_outbound_proto_msgTypes[40].OneofWrappers = []any{
		(*OpaqueRoute_Distribution_Empty_)(nil),
		(*OpaqueRoute_Distribution_FirstAvailable_)(nil),
		(*OpaqueRoute_Distribution_RandomAvailable_)(nil),
	}
	file_outbound_proto_msgTypes[47].OneofWrappers = []any{
		(*TlsRoute_Filter_Invalid)(nil),
		(*TlsRoute_Filter_Forbidden)(nil),
	}
	file_outbound_proto_msgTypes[48].OneofWrappers = []any{
		(*TlsRoute_Distribution_Empty_)(nil),
		(*TlsRoute_Distribution_FirstAvailable_)(nil),
		(*TlsRoute_Distribution_RandomAvailable_)(nil),
	}
	file_outbound_proto_msgTypes[54].OneofWrappers = []any{
		(*Backend_EndpointDiscovery_Dst)(nil),
	}
	file_outbound_proto_msgTypes[55].OneofWrappers = []any{
		(*Backend_BalanceP2C_PeakEwma_)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_outbound_proto_rawDesc), len(file_outbound_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   59,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_outbound_proto_goTypes,
		DependencyIndexes: file_outbound_proto_depIdxs,
		MessageInfos:      file_outbound_proto_msgTypes,
	}.Build()
	File_outbound_proto = out.File
	file_outbound_proto_goTypes = nil
	file_outbound_proto_depIdxs = nil
}
