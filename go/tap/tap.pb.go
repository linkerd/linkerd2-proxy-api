// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tap.proto

/*
Package tap is a generated protocol buffer package.

It is generated from these files:
	tap.proto

It has these top-level messages:
	ObserveRequest
	HttpMethod
	Scheme
	Eos
	TapEvent
*/
package tap

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/duration"
import io_linkerd_proxy_net "github.com/linkerd/linkerd2-proxy-api/go/net"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HttpMethod_Registered int32

const (
	HttpMethod_GET     HttpMethod_Registered = 0
	HttpMethod_POST    HttpMethod_Registered = 1
	HttpMethod_PUT     HttpMethod_Registered = 2
	HttpMethod_DELETE  HttpMethod_Registered = 3
	HttpMethod_PATCH   HttpMethod_Registered = 4
	HttpMethod_OPTIONS HttpMethod_Registered = 5
	HttpMethod_CONNECT HttpMethod_Registered = 6
	HttpMethod_HEAD    HttpMethod_Registered = 7
	HttpMethod_TRACE   HttpMethod_Registered = 8
)

var HttpMethod_Registered_name = map[int32]string{
	0: "GET",
	1: "POST",
	2: "PUT",
	3: "DELETE",
	4: "PATCH",
	5: "OPTIONS",
	6: "CONNECT",
	7: "HEAD",
	8: "TRACE",
}
var HttpMethod_Registered_value = map[string]int32{
	"GET":     0,
	"POST":    1,
	"PUT":     2,
	"DELETE":  3,
	"PATCH":   4,
	"OPTIONS": 5,
	"CONNECT": 6,
	"HEAD":    7,
	"TRACE":   8,
}

func (x HttpMethod_Registered) String() string {
	return proto.EnumName(HttpMethod_Registered_name, int32(x))
}
func (HttpMethod_Registered) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Scheme_Registered int32

const (
	Scheme_HTTP  Scheme_Registered = 0
	Scheme_HTTPS Scheme_Registered = 1
)

var Scheme_Registered_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}
var Scheme_Registered_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (x Scheme_Registered) String() string {
	return proto.EnumName(Scheme_Registered_name, int32(x))
}
func (Scheme_Registered) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type TapEvent_ProxyDirection int32

const (
	TapEvent_UNKNOWN  TapEvent_ProxyDirection = 0
	TapEvent_INBOUND  TapEvent_ProxyDirection = 1
	TapEvent_OUTBOUND TapEvent_ProxyDirection = 2
)

var TapEvent_ProxyDirection_name = map[int32]string{
	0: "UNKNOWN",
	1: "INBOUND",
	2: "OUTBOUND",
}
var TapEvent_ProxyDirection_value = map[string]int32{
	"UNKNOWN":  0,
	"INBOUND":  1,
	"OUTBOUND": 2,
}

func (x TapEvent_ProxyDirection) String() string {
	return proto.EnumName(TapEvent_ProxyDirection_name, int32(x))
}
func (TapEvent_ProxyDirection) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type ObserveRequest struct {
	// Limits the number of event keys that will be returned by this tap.
	Limit uint32 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// Encodes request-matching logic.
	Match *ObserveRequest_Match `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
}

func (m *ObserveRequest) Reset()                    { *m = ObserveRequest{} }
func (m *ObserveRequest) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest) ProtoMessage()               {}
func (*ObserveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ObserveRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ObserveRequest) GetMatch() *ObserveRequest_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

type ObserveRequest_Match struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_All
	//	*ObserveRequest_Match_Any
	//	*ObserveRequest_Match_Not
	//	*ObserveRequest_Match_Source
	//	*ObserveRequest_Match_Destination
	//	*ObserveRequest_Match_Http_
	//	*ObserveRequest_Match_DestinationLabel
	Match isObserveRequest_Match_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match) Reset()                    { *m = ObserveRequest_Match{} }
func (m *ObserveRequest_Match) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match) ProtoMessage()               {}
func (*ObserveRequest_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type isObserveRequest_Match_Match interface{ isObserveRequest_Match_Match() }

type ObserveRequest_Match_All struct {
	All *ObserveRequest_Match_Seq `protobuf:"bytes,1,opt,name=all,oneof"`
}
type ObserveRequest_Match_Any struct {
	Any *ObserveRequest_Match_Seq `protobuf:"bytes,2,opt,name=any,oneof"`
}
type ObserveRequest_Match_Not struct {
	Not *ObserveRequest_Match `protobuf:"bytes,3,opt,name=not,oneof"`
}
type ObserveRequest_Match_Source struct {
	Source *ObserveRequest_Match_Tcp `protobuf:"bytes,4,opt,name=source,oneof"`
}
type ObserveRequest_Match_Destination struct {
	Destination *ObserveRequest_Match_Tcp `protobuf:"bytes,5,opt,name=destination,oneof"`
}
type ObserveRequest_Match_Http_ struct {
	Http *ObserveRequest_Match_Http `protobuf:"bytes,6,opt,name=http,oneof"`
}
type ObserveRequest_Match_DestinationLabel struct {
	DestinationLabel *ObserveRequest_Match_Label `protobuf:"bytes,7,opt,name=destination_label,json=destinationLabel,oneof"`
}

func (*ObserveRequest_Match_All) isObserveRequest_Match_Match()              {}
func (*ObserveRequest_Match_Any) isObserveRequest_Match_Match()              {}
func (*ObserveRequest_Match_Not) isObserveRequest_Match_Match()              {}
func (*ObserveRequest_Match_Source) isObserveRequest_Match_Match()           {}
func (*ObserveRequest_Match_Destination) isObserveRequest_Match_Match()      {}
func (*ObserveRequest_Match_Http_) isObserveRequest_Match_Match()            {}
func (*ObserveRequest_Match_DestinationLabel) isObserveRequest_Match_Match() {}

func (m *ObserveRequest_Match) GetMatch() isObserveRequest_Match_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match) GetAll() *ObserveRequest_Match_Seq {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_All); ok {
		return x.All
	}
	return nil
}

func (m *ObserveRequest_Match) GetAny() *ObserveRequest_Match_Seq {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Any); ok {
		return x.Any
	}
	return nil
}

func (m *ObserveRequest_Match) GetNot() *ObserveRequest_Match {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Not); ok {
		return x.Not
	}
	return nil
}

func (m *ObserveRequest_Match) GetSource() *ObserveRequest_Match_Tcp {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Source); ok {
		return x.Source
	}
	return nil
}

func (m *ObserveRequest_Match) GetDestination() *ObserveRequest_Match_Tcp {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Destination); ok {
		return x.Destination
	}
	return nil
}

func (m *ObserveRequest_Match) GetHttp() *ObserveRequest_Match_Http {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_); ok {
		return x.Http
	}
	return nil
}

func (m *ObserveRequest_Match) GetDestinationLabel() *ObserveRequest_Match_Label {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_DestinationLabel); ok {
		return x.DestinationLabel
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_OneofMarshaler, _ObserveRequest_Match_OneofUnmarshaler, _ObserveRequest_Match_OneofSizer, []interface{}{
		(*ObserveRequest_Match_All)(nil),
		(*ObserveRequest_Match_Any)(nil),
		(*ObserveRequest_Match_Not)(nil),
		(*ObserveRequest_Match_Source)(nil),
		(*ObserveRequest_Match_Destination)(nil),
		(*ObserveRequest_Match_Http_)(nil),
		(*ObserveRequest_Match_DestinationLabel)(nil),
	}
}

func _ObserveRequest_Match_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_All:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *ObserveRequest_Match_Any:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *ObserveRequest_Match_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *ObserveRequest_Match_Source:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Source); err != nil {
			return err
		}
	case *ObserveRequest_Match_Destination:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Destination); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case *ObserveRequest_Match_DestinationLabel:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DestinationLabel); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match)
	switch tag {
	case 1: // match.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_All{msg}
		return true, err
	case 2: // match.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Any{msg}
		return true, err
	case 3: // match.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Not{msg}
		return true, err
	case 4: // match.source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Source{msg}
		return true, err
	case 5: // match.destination
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Destination{msg}
		return true, err
	case 6: // match.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Http)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_{msg}
		return true, err
	case 7: // match.destination_label
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Label)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_DestinationLabel{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_All:
		s := proto.Size(x.All)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Any:
		s := proto.Size(x.Any)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Not:
		s := proto.Size(x.Not)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Source:
		s := proto.Size(x.Source)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Destination:
		s := proto.Size(x.Destination)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_DestinationLabel:
		s := proto.Size(x.DestinationLabel)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObserveRequest_Match_Seq struct {
	Matches []*ObserveRequest_Match `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
}

func (m *ObserveRequest_Match_Seq) Reset()                    { *m = ObserveRequest_Match_Seq{} }
func (m *ObserveRequest_Match_Seq) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Seq) ProtoMessage()               {}
func (*ObserveRequest_Match_Seq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 0} }

func (m *ObserveRequest_Match_Seq) GetMatches() []*ObserveRequest_Match {
	if m != nil {
		return m.Matches
	}
	return nil
}

type ObserveRequest_Match_Label struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *ObserveRequest_Match_Label) Reset()         { *m = ObserveRequest_Match_Label{} }
func (m *ObserveRequest_Match_Label) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Label) ProtoMessage()    {}
func (*ObserveRequest_Match_Label) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 1}
}

func (m *ObserveRequest_Match_Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ObserveRequest_Match_Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ObserveRequest_Match_Tcp struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_Tcp_Netmask_
	//	*ObserveRequest_Match_Tcp_Ports
	Match isObserveRequest_Match_Tcp_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match_Tcp) Reset()                    { *m = ObserveRequest_Match_Tcp{} }
func (m *ObserveRequest_Match_Tcp) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Tcp) ProtoMessage()               {}
func (*ObserveRequest_Match_Tcp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 2} }

type isObserveRequest_Match_Tcp_Match interface{ isObserveRequest_Match_Tcp_Match() }

type ObserveRequest_Match_Tcp_Netmask_ struct {
	Netmask *ObserveRequest_Match_Tcp_Netmask `protobuf:"bytes,1,opt,name=netmask,oneof"`
}
type ObserveRequest_Match_Tcp_Ports struct {
	Ports *ObserveRequest_Match_Tcp_PortRange `protobuf:"bytes,3,opt,name=ports,oneof"`
}

func (*ObserveRequest_Match_Tcp_Netmask_) isObserveRequest_Match_Tcp_Match() {}
func (*ObserveRequest_Match_Tcp_Ports) isObserveRequest_Match_Tcp_Match()    {}

func (m *ObserveRequest_Match_Tcp) GetMatch() isObserveRequest_Match_Tcp_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match_Tcp) GetNetmask() *ObserveRequest_Match_Tcp_Netmask {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Tcp_Netmask_); ok {
		return x.Netmask
	}
	return nil
}

func (m *ObserveRequest_Match_Tcp) GetPorts() *ObserveRequest_Match_Tcp_PortRange {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Tcp_Ports); ok {
		return x.Ports
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match_Tcp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_Tcp_OneofMarshaler, _ObserveRequest_Match_Tcp_OneofUnmarshaler, _ObserveRequest_Match_Tcp_OneofSizer, []interface{}{
		(*ObserveRequest_Match_Tcp_Netmask_)(nil),
		(*ObserveRequest_Match_Tcp_Ports)(nil),
	}
}

func _ObserveRequest_Match_Tcp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match_Tcp)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Tcp_Netmask_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Netmask); err != nil {
			return err
		}
	case *ObserveRequest_Match_Tcp_Ports:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ports); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match_Tcp.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_Tcp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match_Tcp)
	switch tag {
	case 1: // match.netmask
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp_Netmask)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Tcp_Netmask_{msg}
		return true, err
	case 3: // match.ports
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp_PortRange)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Tcp_Ports{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_Tcp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match_Tcp)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Tcp_Netmask_:
		s := proto.Size(x.Netmask)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Tcp_Ports:
		s := proto.Size(x.Ports)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObserveRequest_Match_Tcp_Netmask struct {
	Ip   *io_linkerd_proxy_net.IPAddress `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Mask uint32                          `protobuf:"varint,2,opt,name=mask" json:"mask,omitempty"`
}

func (m *ObserveRequest_Match_Tcp_Netmask) Reset()         { *m = ObserveRequest_Match_Tcp_Netmask{} }
func (m *ObserveRequest_Match_Tcp_Netmask) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Tcp_Netmask) ProtoMessage()    {}
func (*ObserveRequest_Match_Tcp_Netmask) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 2, 0}
}

func (m *ObserveRequest_Match_Tcp_Netmask) GetIp() *io_linkerd_proxy_net.IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *ObserveRequest_Match_Tcp_Netmask) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

// If either a minimum or maximum is not specified, the range is considered to be
// over a discrete value.
type ObserveRequest_Match_Tcp_PortRange struct {
	// Minimum matching port value (inclusive), if specified.
	Min uint32 `protobuf:"varint,1,opt,name=min" json:"min,omitempty"`
	// Maximum matching port value (inclusive), if specified.
	Max uint32 `protobuf:"varint,2,opt,name=max" json:"max,omitempty"`
}

func (m *ObserveRequest_Match_Tcp_PortRange) Reset()         { *m = ObserveRequest_Match_Tcp_PortRange{} }
func (m *ObserveRequest_Match_Tcp_PortRange) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Tcp_PortRange) ProtoMessage()    {}
func (*ObserveRequest_Match_Tcp_PortRange) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 2, 1}
}

func (m *ObserveRequest_Match_Tcp_PortRange) GetMin() uint32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *ObserveRequest_Match_Tcp_PortRange) GetMax() uint32 {
	if m != nil {
		return m.Max
	}
	return 0
}

type ObserveRequest_Match_Http struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_Http_Scheme
	//	*ObserveRequest_Match_Http_Method
	//	*ObserveRequest_Match_Http_Authority
	//	*ObserveRequest_Match_Http_Path
	Match isObserveRequest_Match_Http_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match_Http) Reset()                    { *m = ObserveRequest_Match_Http{} }
func (m *ObserveRequest_Match_Http) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Http) ProtoMessage()               {}
func (*ObserveRequest_Match_Http) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 3} }

type isObserveRequest_Match_Http_Match interface{ isObserveRequest_Match_Http_Match() }

type ObserveRequest_Match_Http_Scheme struct {
	Scheme *Scheme `protobuf:"bytes,1,opt,name=scheme,oneof"`
}
type ObserveRequest_Match_Http_Method struct {
	Method *HttpMethod `protobuf:"bytes,3,opt,name=method,oneof"`
}
type ObserveRequest_Match_Http_Authority struct {
	Authority *ObserveRequest_Match_Http_StringMatch `protobuf:"bytes,2,opt,name=authority,oneof"`
}
type ObserveRequest_Match_Http_Path struct {
	Path *ObserveRequest_Match_Http_StringMatch `protobuf:"bytes,4,opt,name=path,oneof"`
}

func (*ObserveRequest_Match_Http_Scheme) isObserveRequest_Match_Http_Match()    {}
func (*ObserveRequest_Match_Http_Method) isObserveRequest_Match_Http_Match()    {}
func (*ObserveRequest_Match_Http_Authority) isObserveRequest_Match_Http_Match() {}
func (*ObserveRequest_Match_Http_Path) isObserveRequest_Match_Http_Match()      {}

func (m *ObserveRequest_Match_Http) GetMatch() isObserveRequest_Match_Http_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetScheme() *Scheme {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Scheme); ok {
		return x.Scheme
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetMethod() *HttpMethod {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Method); ok {
		return x.Method
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetAuthority() *ObserveRequest_Match_Http_StringMatch {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Authority); ok {
		return x.Authority
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetPath() *ObserveRequest_Match_Http_StringMatch {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Path); ok {
		return x.Path
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match_Http) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_Http_OneofMarshaler, _ObserveRequest_Match_Http_OneofUnmarshaler, _ObserveRequest_Match_Http_OneofSizer, []interface{}{
		(*ObserveRequest_Match_Http_Scheme)(nil),
		(*ObserveRequest_Match_Http_Method)(nil),
		(*ObserveRequest_Match_Http_Authority)(nil),
		(*ObserveRequest_Match_Http_Path)(nil),
	}
}

func _ObserveRequest_Match_Http_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match_Http)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_Scheme:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scheme); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_Method:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Method); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_Authority:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Authority); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_Path:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Path); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match_Http.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_Http_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match_Http)
	switch tag {
	case 1: // match.scheme
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Scheme)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Scheme{msg}
		return true, err
	case 3: // match.method
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpMethod)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Method{msg}
		return true, err
	case 2: // match.authority
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Http_StringMatch)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Authority{msg}
		return true, err
	case 4: // match.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Http_StringMatch)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Path{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_Http_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match_Http)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_Scheme:
		s := proto.Size(x.Scheme)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_Method:
		s := proto.Size(x.Method)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_Authority:
		s := proto.Size(x.Authority)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_Path:
		s := proto.Size(x.Path)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObserveRequest_Match_Http_StringMatch struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_Http_StringMatch_Exact
	//	*ObserveRequest_Match_Http_StringMatch_Prefix
	Match isObserveRequest_Match_Http_StringMatch_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match_Http_StringMatch) Reset()         { *m = ObserveRequest_Match_Http_StringMatch{} }
func (m *ObserveRequest_Match_Http_StringMatch) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Http_StringMatch) ProtoMessage()    {}
func (*ObserveRequest_Match_Http_StringMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 3, 0}
}

type isObserveRequest_Match_Http_StringMatch_Match interface{ isObserveRequest_Match_Http_StringMatch_Match() }

type ObserveRequest_Match_Http_StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,oneof"`
}
type ObserveRequest_Match_Http_StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,oneof"`
}

func (*ObserveRequest_Match_Http_StringMatch_Exact) isObserveRequest_Match_Http_StringMatch_Match()  {}
func (*ObserveRequest_Match_Http_StringMatch_Prefix) isObserveRequest_Match_Http_StringMatch_Match() {}

func (m *ObserveRequest_Match_Http_StringMatch) GetMatch() isObserveRequest_Match_Http_StringMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match_Http_StringMatch) GetExact() string {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *ObserveRequest_Match_Http_StringMatch) GetPrefix() string {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match_Http_StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_Http_StringMatch_OneofMarshaler, _ObserveRequest_Match_Http_StringMatch_OneofUnmarshaler, _ObserveRequest_Match_Http_StringMatch_OneofSizer, []interface{}{
		(*ObserveRequest_Match_Http_StringMatch_Exact)(nil),
		(*ObserveRequest_Match_Http_StringMatch_Prefix)(nil),
	}
}

func _ObserveRequest_Match_Http_StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match_Http_StringMatch)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_StringMatch_Exact:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case *ObserveRequest_Match_Http_StringMatch_Prefix:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match_Http_StringMatch.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_Http_StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match_Http_StringMatch)
	switch tag {
	case 1: // match.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Match = &ObserveRequest_Match_Http_StringMatch_Exact{x}
		return true, err
	case 2: // match.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Match = &ObserveRequest_Match_Http_StringMatch_Prefix{x}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_Http_StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match_Http_StringMatch)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_StringMatch_Exact:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *ObserveRequest_Match_Http_StringMatch_Prefix:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HttpMethod struct {
	// Types that are valid to be assigned to Type:
	//	*HttpMethod_Registered_
	//	*HttpMethod_Unregistered
	Type isHttpMethod_Type `protobuf_oneof:"type"`
}

func (m *HttpMethod) Reset()                    { *m = HttpMethod{} }
func (m *HttpMethod) String() string            { return proto.CompactTextString(m) }
func (*HttpMethod) ProtoMessage()               {}
func (*HttpMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isHttpMethod_Type interface{ isHttpMethod_Type() }

type HttpMethod_Registered_ struct {
	Registered HttpMethod_Registered `protobuf:"varint,1,opt,name=registered,enum=io.linkerd.proxy.tap.HttpMethod_Registered,oneof"`
}
type HttpMethod_Unregistered struct {
	Unregistered string `protobuf:"bytes,2,opt,name=unregistered,oneof"`
}

func (*HttpMethod_Registered_) isHttpMethod_Type()  {}
func (*HttpMethod_Unregistered) isHttpMethod_Type() {}

func (m *HttpMethod) GetType() isHttpMethod_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *HttpMethod) GetRegistered() HttpMethod_Registered {
	if x, ok := m.GetType().(*HttpMethod_Registered_); ok {
		return x.Registered
	}
	return HttpMethod_GET
}

func (m *HttpMethod) GetUnregistered() string {
	if x, ok := m.GetType().(*HttpMethod_Unregistered); ok {
		return x.Unregistered
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpMethod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpMethod_OneofMarshaler, _HttpMethod_OneofUnmarshaler, _HttpMethod_OneofSizer, []interface{}{
		(*HttpMethod_Registered_)(nil),
		(*HttpMethod_Unregistered)(nil),
	}
}

func _HttpMethod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpMethod)
	// type
	switch x := m.Type.(type) {
	case *HttpMethod_Registered_:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Registered))
	case *HttpMethod_Unregistered:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Unregistered)
	case nil:
	default:
		return fmt.Errorf("HttpMethod.Type has unexpected type %T", x)
	}
	return nil
}

func _HttpMethod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpMethod)
	switch tag {
	case 1: // type.registered
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HttpMethod_Registered_{HttpMethod_Registered(x)}
		return true, err
	case 2: // type.unregistered
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &HttpMethod_Unregistered{x}
		return true, err
	default:
		return false, nil
	}
}

func _HttpMethod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpMethod)
	// type
	switch x := m.Type.(type) {
	case *HttpMethod_Registered_:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Registered))
	case *HttpMethod_Unregistered:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Unregistered)))
		n += len(x.Unregistered)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Scheme struct {
	// Types that are valid to be assigned to Type:
	//	*Scheme_Registered_
	//	*Scheme_Unregistered
	Type isScheme_Type `protobuf_oneof:"type"`
}

func (m *Scheme) Reset()                    { *m = Scheme{} }
func (m *Scheme) String() string            { return proto.CompactTextString(m) }
func (*Scheme) ProtoMessage()               {}
func (*Scheme) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isScheme_Type interface{ isScheme_Type() }

type Scheme_Registered_ struct {
	Registered Scheme_Registered `protobuf:"varint,1,opt,name=registered,enum=io.linkerd.proxy.tap.Scheme_Registered,oneof"`
}
type Scheme_Unregistered struct {
	Unregistered string `protobuf:"bytes,2,opt,name=unregistered,oneof"`
}

func (*Scheme_Registered_) isScheme_Type()  {}
func (*Scheme_Unregistered) isScheme_Type() {}

func (m *Scheme) GetType() isScheme_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Scheme) GetRegistered() Scheme_Registered {
	if x, ok := m.GetType().(*Scheme_Registered_); ok {
		return x.Registered
	}
	return Scheme_HTTP
}

func (m *Scheme) GetUnregistered() string {
	if x, ok := m.GetType().(*Scheme_Unregistered); ok {
		return x.Unregistered
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Scheme) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Scheme_OneofMarshaler, _Scheme_OneofUnmarshaler, _Scheme_OneofSizer, []interface{}{
		(*Scheme_Registered_)(nil),
		(*Scheme_Unregistered)(nil),
	}
}

func _Scheme_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Scheme)
	// type
	switch x := m.Type.(type) {
	case *Scheme_Registered_:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Registered))
	case *Scheme_Unregistered:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Unregistered)
	case nil:
	default:
		return fmt.Errorf("Scheme.Type has unexpected type %T", x)
	}
	return nil
}

func _Scheme_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Scheme)
	switch tag {
	case 1: // type.registered
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &Scheme_Registered_{Scheme_Registered(x)}
		return true, err
	case 2: // type.unregistered
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &Scheme_Unregistered{x}
		return true, err
	default:
		return false, nil
	}
}

func _Scheme_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Scheme)
	// type
	switch x := m.Type.(type) {
	case *Scheme_Registered_:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Registered))
	case *Scheme_Unregistered:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Unregistered)))
		n += len(x.Unregistered)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Eos struct {
	// Types that are valid to be assigned to End:
	//	*Eos_GrpcStatusCode
	//	*Eos_ResetErrorCode
	End isEos_End `protobuf_oneof:"end"`
}

func (m *Eos) Reset()                    { *m = Eos{} }
func (m *Eos) String() string            { return proto.CompactTextString(m) }
func (*Eos) ProtoMessage()               {}
func (*Eos) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isEos_End interface{ isEos_End() }

type Eos_GrpcStatusCode struct {
	GrpcStatusCode uint32 `protobuf:"varint,1,opt,name=grpc_status_code,json=grpcStatusCode,oneof"`
}
type Eos_ResetErrorCode struct {
	ResetErrorCode uint32 `protobuf:"varint,2,opt,name=reset_error_code,json=resetErrorCode,oneof"`
}

func (*Eos_GrpcStatusCode) isEos_End() {}
func (*Eos_ResetErrorCode) isEos_End() {}

func (m *Eos) GetEnd() isEos_End {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Eos) GetGrpcStatusCode() uint32 {
	if x, ok := m.GetEnd().(*Eos_GrpcStatusCode); ok {
		return x.GrpcStatusCode
	}
	return 0
}

func (m *Eos) GetResetErrorCode() uint32 {
	if x, ok := m.GetEnd().(*Eos_ResetErrorCode); ok {
		return x.ResetErrorCode
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Eos) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Eos_OneofMarshaler, _Eos_OneofUnmarshaler, _Eos_OneofSizer, []interface{}{
		(*Eos_GrpcStatusCode)(nil),
		(*Eos_ResetErrorCode)(nil),
	}
}

func _Eos_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Eos)
	// end
	switch x := m.End.(type) {
	case *Eos_GrpcStatusCode:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.GrpcStatusCode))
	case *Eos_ResetErrorCode:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ResetErrorCode))
	case nil:
	default:
		return fmt.Errorf("Eos.End has unexpected type %T", x)
	}
	return nil
}

func _Eos_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Eos)
	switch tag {
	case 1: // end.grpc_status_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.End = &Eos_GrpcStatusCode{uint32(x)}
		return true, err
	case 2: // end.reset_error_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.End = &Eos_ResetErrorCode{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Eos_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Eos)
	// end
	switch x := m.End.(type) {
	case *Eos_GrpcStatusCode:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.GrpcStatusCode))
	case *Eos_ResetErrorCode:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ResetErrorCode))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TapEvent struct {
	Source          *io_linkerd_proxy_net.TcpAddress `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	SourceMeta      *TapEvent_EndpointMeta           `protobuf:"bytes,5,opt,name=source_meta,json=sourceMeta" json:"source_meta,omitempty"`
	Destination     *io_linkerd_proxy_net.TcpAddress `protobuf:"bytes,2,opt,name=destination" json:"destination,omitempty"`
	DestinationMeta *TapEvent_EndpointMeta           `protobuf:"bytes,4,opt,name=destination_meta,json=destinationMeta" json:"destination_meta,omitempty"`
	ProxyDirection  TapEvent_ProxyDirection          `protobuf:"varint,6,opt,name=proxy_direction,json=proxyDirection,enum=io.linkerd.proxy.tap.TapEvent_ProxyDirection" json:"proxy_direction,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*TapEvent_Http_
	Event isTapEvent_Event `protobuf_oneof:"event"`
}

func (m *TapEvent) Reset()                    { *m = TapEvent{} }
func (m *TapEvent) String() string            { return proto.CompactTextString(m) }
func (*TapEvent) ProtoMessage()               {}
func (*TapEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isTapEvent_Event interface{ isTapEvent_Event() }

type TapEvent_Http_ struct {
	Http *TapEvent_Http `protobuf:"bytes,3,opt,name=http,oneof"`
}

func (*TapEvent_Http_) isTapEvent_Event() {}

func (m *TapEvent) GetEvent() isTapEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *TapEvent) GetSource() *io_linkerd_proxy_net.TcpAddress {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *TapEvent) GetSourceMeta() *TapEvent_EndpointMeta {
	if m != nil {
		return m.SourceMeta
	}
	return nil
}

func (m *TapEvent) GetDestination() *io_linkerd_proxy_net.TcpAddress {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *TapEvent) GetDestinationMeta() *TapEvent_EndpointMeta {
	if m != nil {
		return m.DestinationMeta
	}
	return nil
}

func (m *TapEvent) GetProxyDirection() TapEvent_ProxyDirection {
	if m != nil {
		return m.ProxyDirection
	}
	return TapEvent_UNKNOWN
}

func (m *TapEvent) GetHttp() *TapEvent_Http {
	if x, ok := m.GetEvent().(*TapEvent_Http_); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TapEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TapEvent_OneofMarshaler, _TapEvent_OneofUnmarshaler, _TapEvent_OneofSizer, []interface{}{
		(*TapEvent_Http_)(nil),
	}
}

func _TapEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TapEvent)
	// event
	switch x := m.Event.(type) {
	case *TapEvent_Http_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TapEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _TapEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TapEvent)
	switch tag {
	case 3: // event.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TapEvent_Http)
		err := b.DecodeMessage(msg)
		m.Event = &TapEvent_Http_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TapEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TapEvent)
	// event
	switch x := m.Event.(type) {
	case *TapEvent_Http_:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TapEvent_EndpointMeta struct {
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TapEvent_EndpointMeta) Reset()                    { *m = TapEvent_EndpointMeta{} }
func (m *TapEvent_EndpointMeta) String() string            { return proto.CompactTextString(m) }
func (*TapEvent_EndpointMeta) ProtoMessage()               {}
func (*TapEvent_EndpointMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *TapEvent_EndpointMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type TapEvent_Http struct {
	// Types that are valid to be assigned to Event:
	//	*TapEvent_Http_RequestInit_
	//	*TapEvent_Http_ResponseInit_
	//	*TapEvent_Http_ResponseEnd_
	Event isTapEvent_Http_Event `protobuf_oneof:"event"`
}

func (m *TapEvent_Http) Reset()                    { *m = TapEvent_Http{} }
func (m *TapEvent_Http) String() string            { return proto.CompactTextString(m) }
func (*TapEvent_Http) ProtoMessage()               {}
func (*TapEvent_Http) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type isTapEvent_Http_Event interface{ isTapEvent_Http_Event() }

type TapEvent_Http_RequestInit_ struct {
	RequestInit *TapEvent_Http_RequestInit `protobuf:"bytes,1,opt,name=request_init,json=requestInit,oneof"`
}
type TapEvent_Http_ResponseInit_ struct {
	ResponseInit *TapEvent_Http_ResponseInit `protobuf:"bytes,2,opt,name=response_init,json=responseInit,oneof"`
}
type TapEvent_Http_ResponseEnd_ struct {
	ResponseEnd *TapEvent_Http_ResponseEnd `protobuf:"bytes,3,opt,name=response_end,json=responseEnd,oneof"`
}

func (*TapEvent_Http_RequestInit_) isTapEvent_Http_Event()  {}
func (*TapEvent_Http_ResponseInit_) isTapEvent_Http_Event() {}
func (*TapEvent_Http_ResponseEnd_) isTapEvent_Http_Event()  {}

func (m *TapEvent_Http) GetEvent() isTapEvent_Http_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *TapEvent_Http) GetRequestInit() *TapEvent_Http_RequestInit {
	if x, ok := m.GetEvent().(*TapEvent_Http_RequestInit_); ok {
		return x.RequestInit
	}
	return nil
}

func (m *TapEvent_Http) GetResponseInit() *TapEvent_Http_ResponseInit {
	if x, ok := m.GetEvent().(*TapEvent_Http_ResponseInit_); ok {
		return x.ResponseInit
	}
	return nil
}

func (m *TapEvent_Http) GetResponseEnd() *TapEvent_Http_ResponseEnd {
	if x, ok := m.GetEvent().(*TapEvent_Http_ResponseEnd_); ok {
		return x.ResponseEnd
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TapEvent_Http) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TapEvent_Http_OneofMarshaler, _TapEvent_Http_OneofUnmarshaler, _TapEvent_Http_OneofSizer, []interface{}{
		(*TapEvent_Http_RequestInit_)(nil),
		(*TapEvent_Http_ResponseInit_)(nil),
		(*TapEvent_Http_ResponseEnd_)(nil),
	}
}

func _TapEvent_Http_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TapEvent_Http)
	// event
	switch x := m.Event.(type) {
	case *TapEvent_Http_RequestInit_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RequestInit); err != nil {
			return err
		}
	case *TapEvent_Http_ResponseInit_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResponseInit); err != nil {
			return err
		}
	case *TapEvent_Http_ResponseEnd_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResponseEnd); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TapEvent_Http.Event has unexpected type %T", x)
	}
	return nil
}

func _TapEvent_Http_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TapEvent_Http)
	switch tag {
	case 1: // event.request_init
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TapEvent_Http_RequestInit)
		err := b.DecodeMessage(msg)
		m.Event = &TapEvent_Http_RequestInit_{msg}
		return true, err
	case 2: // event.response_init
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TapEvent_Http_ResponseInit)
		err := b.DecodeMessage(msg)
		m.Event = &TapEvent_Http_ResponseInit_{msg}
		return true, err
	case 3: // event.response_end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TapEvent_Http_ResponseEnd)
		err := b.DecodeMessage(msg)
		m.Event = &TapEvent_Http_ResponseEnd_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TapEvent_Http_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TapEvent_Http)
	// event
	switch x := m.Event.(type) {
	case *TapEvent_Http_RequestInit_:
		s := proto.Size(x.RequestInit)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TapEvent_Http_ResponseInit_:
		s := proto.Size(x.ResponseInit)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TapEvent_Http_ResponseEnd_:
		s := proto.Size(x.ResponseEnd)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TapEvent_Http_StreamId struct {
	// A randomized base (stable across a process's runtime)
	Base uint32 `protobuf:"varint,1,opt,name=base" json:"base,omitempty"`
	// A stream id unique within the lifetime of `base`.
	Stream uint64 `protobuf:"varint,2,opt,name=stream" json:"stream,omitempty"`
}

func (m *TapEvent_Http_StreamId) Reset()                    { *m = TapEvent_Http_StreamId{} }
func (m *TapEvent_Http_StreamId) String() string            { return proto.CompactTextString(m) }
func (*TapEvent_Http_StreamId) ProtoMessage()               {}
func (*TapEvent_Http_StreamId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1, 0} }

func (m *TapEvent_Http_StreamId) GetBase() uint32 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *TapEvent_Http_StreamId) GetStream() uint64 {
	if m != nil {
		return m.Stream
	}
	return 0
}

type TapEvent_Http_RequestInit struct {
	Id        *TapEvent_Http_StreamId `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Method    *HttpMethod             `protobuf:"bytes,2,opt,name=method" json:"method,omitempty"`
	Scheme    *Scheme                 `protobuf:"bytes,3,opt,name=scheme" json:"scheme,omitempty"`
	Authority string                  `protobuf:"bytes,4,opt,name=authority" json:"authority,omitempty"`
	Path      string                  `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
}

func (m *TapEvent_Http_RequestInit) Reset()                    { *m = TapEvent_Http_RequestInit{} }
func (m *TapEvent_Http_RequestInit) String() string            { return proto.CompactTextString(m) }
func (*TapEvent_Http_RequestInit) ProtoMessage()               {}
func (*TapEvent_Http_RequestInit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1, 1} }

func (m *TapEvent_Http_RequestInit) GetId() *TapEvent_Http_StreamId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TapEvent_Http_RequestInit) GetMethod() *HttpMethod {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *TapEvent_Http_RequestInit) GetScheme() *Scheme {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *TapEvent_Http_RequestInit) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *TapEvent_Http_RequestInit) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type TapEvent_Http_ResponseInit struct {
	Id               *TapEvent_Http_StreamId   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SinceRequestInit *google_protobuf.Duration `protobuf:"bytes,2,opt,name=since_request_init,json=sinceRequestInit" json:"since_request_init,omitempty"`
	HttpStatus       uint32                    `protobuf:"varint,3,opt,name=http_status,json=httpStatus" json:"http_status,omitempty"`
}

func (m *TapEvent_Http_ResponseInit) Reset()         { *m = TapEvent_Http_ResponseInit{} }
func (m *TapEvent_Http_ResponseInit) String() string { return proto.CompactTextString(m) }
func (*TapEvent_Http_ResponseInit) ProtoMessage()    {}
func (*TapEvent_Http_ResponseInit) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 1, 2}
}

func (m *TapEvent_Http_ResponseInit) GetId() *TapEvent_Http_StreamId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TapEvent_Http_ResponseInit) GetSinceRequestInit() *google_protobuf.Duration {
	if m != nil {
		return m.SinceRequestInit
	}
	return nil
}

func (m *TapEvent_Http_ResponseInit) GetHttpStatus() uint32 {
	if m != nil {
		return m.HttpStatus
	}
	return 0
}

type TapEvent_Http_ResponseEnd struct {
	Id                *TapEvent_Http_StreamId   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SinceRequestInit  *google_protobuf.Duration `protobuf:"bytes,2,opt,name=since_request_init,json=sinceRequestInit" json:"since_request_init,omitempty"`
	SinceResponseInit *google_protobuf.Duration `protobuf:"bytes,3,opt,name=since_response_init,json=sinceResponseInit" json:"since_response_init,omitempty"`
	ResponseBytes     uint64                    `protobuf:"varint,4,opt,name=response_bytes,json=responseBytes" json:"response_bytes,omitempty"`
	Eos               *Eos                      `protobuf:"bytes,5,opt,name=eos" json:"eos,omitempty"`
}

func (m *TapEvent_Http_ResponseEnd) Reset()                    { *m = TapEvent_Http_ResponseEnd{} }
func (m *TapEvent_Http_ResponseEnd) String() string            { return proto.CompactTextString(m) }
func (*TapEvent_Http_ResponseEnd) ProtoMessage()               {}
func (*TapEvent_Http_ResponseEnd) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1, 3} }

func (m *TapEvent_Http_ResponseEnd) GetId() *TapEvent_Http_StreamId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TapEvent_Http_ResponseEnd) GetSinceRequestInit() *google_protobuf.Duration {
	if m != nil {
		return m.SinceRequestInit
	}
	return nil
}

func (m *TapEvent_Http_ResponseEnd) GetSinceResponseInit() *google_protobuf.Duration {
	if m != nil {
		return m.SinceResponseInit
	}
	return nil
}

func (m *TapEvent_Http_ResponseEnd) GetResponseBytes() uint64 {
	if m != nil {
		return m.ResponseBytes
	}
	return 0
}

func (m *TapEvent_Http_ResponseEnd) GetEos() *Eos {
	if m != nil {
		return m.Eos
	}
	return nil
}

func init() {
	proto.RegisterType((*ObserveRequest)(nil), "io.linkerd.proxy.tap.ObserveRequest")
	proto.RegisterType((*ObserveRequest_Match)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match")
	proto.RegisterType((*ObserveRequest_Match_Seq)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Seq")
	proto.RegisterType((*ObserveRequest_Match_Label)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Label")
	proto.RegisterType((*ObserveRequest_Match_Tcp)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Tcp")
	proto.RegisterType((*ObserveRequest_Match_Tcp_Netmask)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Tcp.Netmask")
	proto.RegisterType((*ObserveRequest_Match_Tcp_PortRange)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Tcp.PortRange")
	proto.RegisterType((*ObserveRequest_Match_Http)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Http")
	proto.RegisterType((*ObserveRequest_Match_Http_StringMatch)(nil), "io.linkerd.proxy.tap.ObserveRequest.Match.Http.StringMatch")
	proto.RegisterType((*HttpMethod)(nil), "io.linkerd.proxy.tap.HttpMethod")
	proto.RegisterType((*Scheme)(nil), "io.linkerd.proxy.tap.Scheme")
	proto.RegisterType((*Eos)(nil), "io.linkerd.proxy.tap.Eos")
	proto.RegisterType((*TapEvent)(nil), "io.linkerd.proxy.tap.TapEvent")
	proto.RegisterType((*TapEvent_EndpointMeta)(nil), "io.linkerd.proxy.tap.TapEvent.EndpointMeta")
	proto.RegisterType((*TapEvent_Http)(nil), "io.linkerd.proxy.tap.TapEvent.Http")
	proto.RegisterType((*TapEvent_Http_StreamId)(nil), "io.linkerd.proxy.tap.TapEvent.Http.StreamId")
	proto.RegisterType((*TapEvent_Http_RequestInit)(nil), "io.linkerd.proxy.tap.TapEvent.Http.RequestInit")
	proto.RegisterType((*TapEvent_Http_ResponseInit)(nil), "io.linkerd.proxy.tap.TapEvent.Http.ResponseInit")
	proto.RegisterType((*TapEvent_Http_ResponseEnd)(nil), "io.linkerd.proxy.tap.TapEvent.Http.ResponseEnd")
	proto.RegisterEnum("io.linkerd.proxy.tap.HttpMethod_Registered", HttpMethod_Registered_name, HttpMethod_Registered_value)
	proto.RegisterEnum("io.linkerd.proxy.tap.Scheme_Registered", Scheme_Registered_name, Scheme_Registered_value)
	proto.RegisterEnum("io.linkerd.proxy.tap.TapEvent_ProxyDirection", TapEvent_ProxyDirection_name, TapEvent_ProxyDirection_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Tap service

type TapClient interface {
	Observe(ctx context.Context, in *ObserveRequest, opts ...grpc.CallOption) (Tap_ObserveClient, error)
}

type tapClient struct {
	cc *grpc.ClientConn
}

func NewTapClient(cc *grpc.ClientConn) TapClient {
	return &tapClient{cc}
}

func (c *tapClient) Observe(ctx context.Context, in *ObserveRequest, opts ...grpc.CallOption) (Tap_ObserveClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Tap_serviceDesc.Streams[0], c.cc, "/io.linkerd.proxy.tap.Tap/Observe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tapObserveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tap_ObserveClient interface {
	Recv() (*TapEvent, error)
	grpc.ClientStream
}

type tapObserveClient struct {
	grpc.ClientStream
}

func (x *tapObserveClient) Recv() (*TapEvent, error) {
	m := new(TapEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Tap service

type TapServer interface {
	Observe(*ObserveRequest, Tap_ObserveServer) error
}

func RegisterTapServer(s *grpc.Server, srv TapServer) {
	s.RegisterService(&_Tap_serviceDesc, srv)
}

func _Tap_Observe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObserveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TapServer).Observe(m, &tapObserveServer{stream})
}

type Tap_ObserveServer interface {
	Send(*TapEvent) error
	grpc.ServerStream
}

type tapObserveServer struct {
	grpc.ServerStream
}

func (x *tapObserveServer) Send(m *TapEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _Tap_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.linkerd.proxy.tap.Tap",
	HandlerType: (*TapServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Observe",
			Handler:       _Tap_Observe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "tap.proto",
}

func init() { proto.RegisterFile("tap.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0x17, 0x49, 0x7d, 0x58, 0x23, 0xdb, 0x61, 0xf6, 0x1f, 0x04, 0x0a, 0x11, 0x24, 0xfe, 0xab,
	0x29, 0x1a, 0xe4, 0x83, 0x0a, 0xdc, 0x22, 0x75, 0xd2, 0xa2, 0xa8, 0x65, 0x13, 0x91, 0x90, 0x58,
	0x52, 0x57, 0x74, 0x02, 0xa4, 0x07, 0x81, 0x12, 0x37, 0x12, 0x11, 0x89, 0x64, 0x96, 0xab, 0x20,
	0x7a, 0x95, 0x9e, 0x7b, 0xeb, 0xb1, 0x68, 0xaf, 0x7d, 0x84, 0x5e, 0xfa, 0x1a, 0x7d, 0x80, 0x1e,
	0x0a, 0x14, 0xfb, 0x41, 0x9a, 0x6a, 0x9c, 0xd8, 0x4a, 0x2e, 0x3d, 0x69, 0x67, 0xb8, 0xf3, 0xdb,
	0x99, 0xd9, 0x99, 0xf9, 0xad, 0xa0, 0xca, 0xbc, 0xd8, 0x8e, 0x69, 0xc4, 0x22, 0x74, 0x29, 0x88,
	0xec, 0x59, 0x10, 0xbe, 0x24, 0xd4, 0xe7, 0x9a, 0x37, 0x4b, 0x9b, 0x79, 0xb1, 0x75, 0x6d, 0x12,
	0x45, 0x93, 0x19, 0x69, 0x8a, 0x3d, 0xa3, 0xc5, 0x8b, 0xa6, 0xbf, 0xa0, 0x1e, 0x0b, 0xa2, 0x50,
	0x5a, 0x59, 0xd5, 0x90, 0x30, 0xb9, 0x6c, 0xfc, 0x56, 0x83, 0xed, 0xde, 0x28, 0x21, 0xf4, 0x35,
	0xc1, 0xe4, 0xd5, 0x82, 0x24, 0x0c, 0x5d, 0x82, 0xd2, 0x2c, 0x98, 0x07, 0xac, 0xae, 0xed, 0x68,
	0x37, 0xb7, 0xb0, 0x14, 0xd0, 0xb7, 0x50, 0x9a, 0x7b, 0x6c, 0x3c, 0xad, 0xeb, 0x3b, 0xda, 0xcd,
	0xda, 0xee, 0x2d, 0xfb, 0xb4, 0x93, 0xed, 0x55, 0x28, 0xfb, 0x88, 0x5b, 0x60, 0x69, 0x68, 0xfd,
	0x01, 0x50, 0x12, 0x0a, 0xd4, 0x02, 0xc3, 0x9b, 0xcd, 0x04, 0x7e, 0x6d, 0xd7, 0x3e, 0x3f, 0x92,
	0x3d, 0x20, 0xaf, 0xda, 0x05, 0xcc, 0x8d, 0x05, 0x46, 0xb8, 0x54, 0xde, 0x7c, 0x08, 0x46, 0xb8,
	0x44, 0xdf, 0x80, 0x11, 0x46, 0xac, 0x6e, 0xac, 0x1b, 0x11, 0xb7, 0x0f, 0x23, 0x86, 0xda, 0x50,
	0x4e, 0xa2, 0x05, 0x1d, 0x93, 0x7a, 0x71, 0x6d, 0x37, 0xdc, 0x71, 0xdc, 0x2e, 0x60, 0x65, 0x8f,
	0x30, 0xd4, 0x7c, 0x92, 0xb0, 0x20, 0x14, 0xd7, 0x54, 0x2f, 0x7d, 0x20, 0x5c, 0x1e, 0x04, 0x39,
	0x50, 0x9c, 0x32, 0x16, 0xd7, 0xcb, 0x02, 0xac, 0xb9, 0x06, 0x58, 0x9b, 0x31, 0x8e, 0x26, 0xcc,
	0xd1, 0x10, 0x2e, 0xe6, 0x50, 0x87, 0x33, 0x6f, 0x44, 0x66, 0xf5, 0x8a, 0xc0, 0xbc, 0xb7, 0x06,
	0xe6, 0x13, 0x6e, 0xd7, 0x2e, 0x60, 0x33, 0x07, 0x26, 0x74, 0xd6, 0x63, 0x30, 0x06, 0xe4, 0x15,
	0x3a, 0x84, 0x8a, 0xa8, 0x13, 0x92, 0xd4, 0xb5, 0x1d, 0x63, 0xcd, 0x12, 0x4b, 0x4d, 0xad, 0x26,
	0x94, 0x04, 0x2a, 0x32, 0xc1, 0x78, 0x49, 0x96, 0xa2, 0xc6, 0xaa, 0x98, 0x2f, 0x79, 0x5d, 0xbf,
	0xf6, 0x66, 0x0b, 0x22, 0x6a, 0xa6, 0x8a, 0xa5, 0x60, 0xfd, 0xa2, 0x83, 0xe1, 0x8e, 0x63, 0x84,
	0xa1, 0x12, 0x12, 0x36, 0xf7, 0x92, 0x97, 0xaa, 0x2e, 0xef, 0xaf, 0x97, 0x7d, 0xbb, 0x2b, 0xad,
	0xdb, 0x05, 0x9c, 0x02, 0xa1, 0x3e, 0x94, 0xe2, 0x88, 0xb2, 0x44, 0x55, 0xd8, 0xde, 0x9a, 0x88,
	0xfd, 0x88, 0x32, 0xec, 0x85, 0x13, 0xd2, 0x2e, 0x60, 0x09, 0x64, 0x75, 0xa1, 0xa2, 0xce, 0x41,
	0x4d, 0xd0, 0x83, 0x58, 0xf9, 0x7a, 0xfd, 0x6d, 0x64, 0xde, 0xe2, 0x9d, 0xfe, 0xbe, 0xef, 0x53,
	0x92, 0x24, 0x58, 0x0f, 0x62, 0x84, 0xa0, 0x28, 0xc2, 0xd3, 0x45, 0x5b, 0x8b, 0xb5, 0xd5, 0x84,
	0x6a, 0x76, 0x0a, 0x4f, 0xd9, 0x3c, 0x08, 0x55, 0xdb, 0xf3, 0xa5, 0xd0, 0x78, 0x6f, 0x94, 0x05,
	0x5f, 0xb6, 0x2a, 0x6a, 0x0c, 0x58, 0x7f, 0xeb, 0x50, 0xe4, 0x75, 0x82, 0xee, 0x43, 0x39, 0x19,
	0x4f, 0xc9, 0x9c, 0x28, 0x5f, 0xae, 0x9e, 0x1e, 0xe5, 0x40, 0xec, 0x11, 0x25, 0x2f, 0x56, 0xe8,
	0x21, 0x94, 0xe7, 0x84, 0x4d, 0x23, 0x5f, 0x65, 0x67, 0xe7, 0x74, 0x3b, 0x7e, 0xc6, 0x91, 0xd8,
	0xc7, 0x6d, 0xa5, 0x05, 0xfa, 0x1e, 0xaa, 0xde, 0x82, 0x4d, 0x23, 0x1a, 0xb0, 0x74, 0x04, 0x7c,
	0xb5, 0x66, 0x7d, 0xdb, 0x03, 0x46, 0x83, 0x70, 0x92, 0xf6, 0xf3, 0x09, 0x1e, 0xfa, 0x0e, 0x8a,
	0xb1, 0xc7, 0xa6, 0xaa, 0xa7, 0x3f, 0x12, 0x57, 0x40, 0x59, 0x6d, 0xa8, 0xe5, 0xd4, 0xe8, 0x32,
	0x94, 0xc8, 0x1b, 0x6f, 0x2c, 0x27, 0x6c, 0x95, 0xdf, 0xae, 0x10, 0x51, 0x1d, 0xca, 0x31, 0x25,
	0x2f, 0x02, 0x99, 0x71, 0xfe, 0x41, 0xc9, 0x59, 0xda, 0xdf, 0x5e, 0x34, 0xfe, 0xd2, 0x00, 0x4e,
	0x92, 0x84, 0x8e, 0x00, 0x28, 0x99, 0x04, 0x09, 0x23, 0x94, 0xf8, 0xe2, 0x80, 0xed, 0xdd, 0xdb,
	0x67, 0xa5, 0xd6, 0xc6, 0x99, 0x49, 0xbb, 0x80, 0x73, 0x00, 0xe8, 0x06, 0x6c, 0x2e, 0xc2, 0x1c,
	0x60, 0xea, 0xd8, 0x8a, 0xb6, 0x11, 0x02, 0x9c, 0x20, 0xa0, 0x0a, 0x18, 0x8f, 0x1c, 0xd7, 0x2c,
	0xa0, 0x0d, 0x28, 0xf6, 0x7b, 0x03, 0xd7, 0xd4, 0xb8, 0xaa, 0x7f, 0xec, 0x9a, 0x3a, 0x02, 0x28,
	0x1f, 0x3a, 0x4f, 0x1c, 0xd7, 0x31, 0x0d, 0x54, 0x85, 0x52, 0x7f, 0xdf, 0x3d, 0x68, 0x9b, 0x45,
	0x54, 0x83, 0x4a, 0xaf, 0xef, 0x76, 0x7a, 0xdd, 0x81, 0x59, 0xe2, 0xc2, 0x41, 0xaf, 0xdb, 0x75,
	0x0e, 0x5c, 0xb3, 0xcc, 0x31, 0xda, 0xce, 0xfe, 0xa1, 0x59, 0xe1, 0xdb, 0x5d, 0xbc, 0x7f, 0xe0,
	0x98, 0x1b, 0xad, 0x32, 0x14, 0xd9, 0x32, 0x26, 0x8d, 0x1f, 0x35, 0x28, 0xcb, 0xc2, 0x42, 0x9d,
	0x53, 0xe2, 0xfe, 0xec, 0x7d, 0xa5, 0xf8, 0xb1, 0x31, 0xff, 0x7f, 0x25, 0x66, 0xee, 0xa6, 0xeb,
	0xf6, 0xcd, 0x02, 0x77, 0x93, 0xaf, 0x06, 0xa6, 0x96, 0xb9, 0xe9, 0x83, 0xe1, 0x44, 0x09, 0xba,
	0x05, 0xe6, 0x84, 0xc6, 0xe3, 0x61, 0xc2, 0x3c, 0xb6, 0x48, 0x86, 0xe3, 0xc8, 0x97, 0x3d, 0xb3,
	0xd5, 0x2e, 0xe0, 0x6d, 0xfe, 0x65, 0x20, 0x3e, 0x1c, 0x44, 0x3e, 0xe1, 0x7b, 0x29, 0x49, 0x08,
	0x1b, 0x12, 0x4a, 0x23, 0x2a, 0xf7, 0xea, 0xe9, 0x5e, 0xf1, 0xc5, 0xe1, 0x1f, 0xf8, 0xde, 0x56,
	0x09, 0x0c, 0x12, 0xfa, 0x8d, 0xdf, 0xb7, 0x60, 0xc3, 0xf5, 0x62, 0xe7, 0x35, 0x09, 0x19, 0xda,
	0xcb, 0xa8, 0x49, 0x7b, 0x57, 0x77, 0xf1, 0x09, 0xe1, 0x8e, 0xe3, 0x74, 0x44, 0xa4, 0x54, 0xf4,
	0x04, 0x6a, 0x72, 0x35, 0x9c, 0x13, 0xe6, 0x29, 0x2a, 0x7a, 0x47, 0x05, 0xa5, 0xc7, 0xd9, 0x4e,
	0xe8, 0xc7, 0x51, 0x10, 0xb2, 0x23, 0xc2, 0x3c, 0x0c, 0xd2, 0x9e, 0xaf, 0x51, 0x6b, 0x95, 0xd8,
	0xf4, 0x73, 0x3a, 0xb3, 0x42, 0x64, 0x4f, 0x21, 0x4f, 0x1a, 0xd2, 0xad, 0xe2, 0xfa, 0x6e, 0x5d,
	0xc8, 0x81, 0x08, 0xdf, 0x9e, 0xc2, 0x05, 0x61, 0x33, 0xf4, 0x03, 0x4a, 0xc6, 0xc2, 0xbf, 0xb2,
	0xa8, 0x9b, 0xbb, 0x67, 0xc0, 0xf6, 0xb9, 0xea, 0x30, 0x35, 0xc2, 0xdb, 0xf1, 0x8a, 0x8c, 0x1e,
	0x28, 0xe2, 0x95, 0x73, 0xed, 0x93, 0x33, 0xc0, 0xf2, 0x64, 0x6b, 0xfd, 0xa0, 0xc1, 0x66, 0xde,
	0x69, 0xd4, 0x83, 0xb2, 0x60, 0xdc, 0x94, 0x14, 0xbf, 0x5c, 0x23, 0x62, 0xc9, 0xb9, 0x89, 0x13,
	0x32, 0xba, 0xc4, 0x0a, 0xc6, 0x7a, 0x00, 0xb5, 0x9c, 0xfa, 0xbc, 0x34, 0xf9, 0x50, 0xdf, 0xd3,
	0xac, 0x9f, 0x36, 0xd4, 0xc8, 0x77, 0x61, 0x93, 0xca, 0xc1, 0x37, 0x0c, 0x42, 0xf5, 0x50, 0x7c,
	0xe7, 0x0b, 0x63, 0x25, 0x50, 0x5b, 0x0d, 0xcc, 0x4e, 0x18, 0x30, 0xfe, 0x5e, 0xa1, 0x27, 0x22,
	0x7a, 0x06, 0x5b, 0x94, 0x24, 0x71, 0x14, 0x26, 0x44, 0xc2, 0xea, 0xef, 0x7b, 0x64, 0xfc, 0x1b,
	0x56, 0x1a, 0x2a, 0xdc, 0x4d, 0x9a, 0x93, 0xa5, 0xbb, 0x0a, 0x98, 0x84, 0x29, 0xdf, 0x34, 0xd7,
	0xc1, 0x75, 0x42, 0x5f, 0xba, 0x9b, 0x89, 0xd6, 0x7d, 0xd8, 0x18, 0x30, 0x4a, 0xbc, 0x79, 0xc7,
	0xe7, 0xd4, 0x3a, 0xf2, 0x12, 0xd5, 0xcd, 0x58, 0xac, 0xd1, 0x65, 0x28, 0x27, 0xe2, 0xbb, 0x88,
	0xa3, 0x88, 0x95, 0x64, 0xfd, 0xa9, 0x41, 0x2d, 0x97, 0x05, 0xf4, 0x35, 0xe8, 0x81, 0xaf, 0x52,
	0x78, 0xe7, 0x3c, 0x3e, 0xa5, 0xa7, 0x62, 0x3d, 0xf0, 0x79, 0x9f, 0x2b, 0x16, 0xd5, 0xcf, 0xc7,
	0xa2, 0x19, 0x87, 0x7e, 0x91, 0xf1, 0xb6, 0x71, 0x36, 0x6f, 0x67, 0xac, 0x7d, 0x35, 0xcf, 0xbc,
	0x45, 0x51, 0x21, 0x39, 0xea, 0x44, 0x8a, 0x3a, 0x4b, 0xe2, 0x83, 0xe4, 0xbe, 0x5f, 0x35, 0xd8,
	0xcc, 0x5f, 0xcf, 0x47, 0x06, 0xfc, 0x08, 0x50, 0x12, 0x84, 0x63, 0x32, 0x5c, 0xa9, 0x40, 0x19,
	0xfc, 0x15, 0x5b, 0xfe, 0xf1, 0xb1, 0xd3, 0x3f, 0x3e, 0xf6, 0xa1, 0xfa, 0xe3, 0x83, 0x4d, 0x61,
	0x94, 0xcf, 0xfb, 0x75, 0xa8, 0xf1, 0x96, 0x53, 0xd3, 0x58, 0x24, 0x61, 0x0b, 0x03, 0x57, 0xc9,
	0x31, 0x6c, 0xfd, 0xac, 0xf3, 0x8b, 0xca, 0x2e, 0xfc, 0xbf, 0xe2, 0x77, 0x07, 0xfe, 0x97, 0x02,
	0xe5, 0x9b, 0xc5, 0x38, 0x0b, 0xe9, 0xa2, 0x42, 0xca, 0xdd, 0xc4, 0xa7, 0xb0, 0x9d, 0x81, 0x8c,
	0x96, 0x8c, 0x24, 0xe2, 0x46, 0x8b, 0x38, 0xeb, 0xc3, 0x16, 0x57, 0xa2, 0xdb, 0x60, 0x90, 0x28,
	0x51, 0x4c, 0x70, 0xe5, 0xf4, 0xc8, 0x9d, 0x28, 0xc1, 0x7c, 0x17, 0x7f, 0x97, 0x10, 0x9e, 0x82,
	0xc6, 0x1e, 0x6c, 0xaf, 0xce, 0x49, 0xce, 0xeb, 0xc7, 0xdd, 0xc7, 0xdd, 0xde, 0xb3, 0xae, 0x59,
	0xe0, 0x42, 0xa7, 0xdb, 0xea, 0x1d, 0x77, 0x0f, 0x4d, 0x0d, 0x6d, 0xc2, 0x46, 0xef, 0xd8, 0x95,
	0x92, 0x9e, 0x41, 0xec, 0x3e, 0x07, 0xc3, 0xf5, 0x62, 0x34, 0x80, 0x8a, 0x7a, 0x6e, 0xa1, 0x1b,
	0xe7, 0x79, 0x8d, 0x59, 0xd7, 0xde, 0x7f, 0x3b, 0x8d, 0xc2, 0x3d, 0xad, 0x65, 0x3f, 0xbf, 0x33,
	0x09, 0xd8, 0x74, 0x31, 0xb2, 0xc7, 0xd1, 0xbc, 0xa9, 0x36, 0xa7, 0xbf, 0xbb, 0x77, 0x85, 0xd5,
	0x5d, 0x2f, 0x0e, 0x9a, 0x93, 0xa8, 0xc9, 0xbc, 0x78, 0x54, 0x16, 0x19, 0xfd, 0xfc, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x34, 0x1a, 0xe4, 0xe1, 0x7d, 0x0f, 0x00, 0x00,
}
