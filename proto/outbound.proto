syntax = "proto3";

package io.linkerd.proxy.outbound;

option go_package = "github.com/linkerd/linkerd2-proxy-api/go/outbound";

import "net.proto";
import "destination.proto";
import "meta.proto";
import "http_route.proto";
import "google/protobuf/duration.proto";

service OutboundPolicies {
  rpc Get(TargetSpec) returns (Service) {}

  rpc Watch(TargetSpec) returns (stream Service) {}
}

message TargetSpec {
  // Identifies the source proxy workload (e.g., pod name).
  string workload = 1;

  // Target address. This may be the cluster IP of a Kubernetes Service or the
  // IP of a Pod.
  io.linkerd.proxy.net.IPAddress address = 2;

  // Target port
  uint32 port = 3;
}

// Outbound policy for a given target address.
// TODO: This "Service" represents a traffic target of some kind, but is not
// necessarily a Kubernetes Service (e.g. it may be a Pod).  Is there a better
// name for this type?  OutboundPolicy?
message Service {
  // Indicates the protocol to use for this target.  This will be set to Opaque
  // if the target has been marked as opaque and will be Discover otherwise.
  ProxyProtocol protocol = 1;

  // The backend to use for this target.  If the target is a Service, the
  // backend will be a Dst containing the FQDN of the Service.  If the target
  // is a Pod, it will be an endpoint address.
  Backend backend = 2;
}

message ProxyProtocol {
  oneof kind {
    Detect detect = 1;
    Opaque opaque = 2;
  }

  message Detect {
    // Protocol detection timeout.
    google.protobuf.Duration timeout = 1;

    // If the protocol detected as HTTP, a list of HTTP routes that should be
    // matched.
    repeated HttpRoute http_routes = 2;
  }

  message Opaque {}
}

// Outbound-specific HTTP route configuration (based on the [Gateway API][api]).
//
// [api]: https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.HTTPRoute
message HttpRoute {
  io.linkerd.proxy.meta.Metadata metadata = 1;

  // If empty, the host value is ignored.
  repeated io.linkerd.proxy.http_route.HostMatch hosts = 2;

  // Must have at least one rule.
  repeated Rule rules = 3;

  message Rule {
    repeated io.linkerd.proxy.http_route.HttpRouteMatch matches = 1;
    repeated Backend backends = 2;
  }
}

message Backend {
  oneof backend {
    io.linkerd.proxy.destination.WeightedDst dst = 1;
    io.linkerd.proxy.destination.WeightedAddr endpoint = 2;
  }
}
