syntax = "proto3";

package io.linkerd.proxy.destination;

option go_package = "github.com/linkerd/linkerd2-proxy-api/go/destination";

import "google/protobuf/duration.proto";

import "http_types.proto";
import "net.proto";

/// Destination Service ///
//
// This is the service discovery API.  Given a destination, this returns a
// weighted set of addresses and address metadata.  Can be implemented with DNS
// or lookups against other service discovery backends.
//
// If the service does not exist then the controller must send
// `no_endpoints{exists: false}` ASAP when a client subscribes or when the
// service stops existing. If the service exists and has endpoints available
// then the controller must send `add` that lists all (or at least a large
// number) of the endpoints for the service. If and only if the service exists
// but does not have any endpoints available then the controller SHOULD send
// `no_endpoints{exists: true}` when a client subscribes. In other words, the
// `no_endpoints` message must only be sent when there are *no*endpoints for
// the service.
//
// The controller is expected to send an Update every time there is a
// change in service discovery.
//
// The client MUST be prepared to receive messages in any order and the client
// MUST be able to cope with the presence or absence of redundant messages.
//
// `no_endpoints` followed by an `add` is *not* equivalent to just sending the
// `add` regardless of the value of the `exists` field in the `no_endpoints`
// message. `remove` followed by a `no_endpoints` message is equivalent to
// sending just the `no_endpoints` message, and a `remove` that removes the
// last endpoint is equivalent to a `no_endpoints{exists: true}` message.
//
// When the client gets disconnected from the controller and reconnects, the
// client may use stale results from its previous subscription until, and only
// until, it receives the first message. This is why the controller must send
// a message at the start of a subscription. This is also why the controller
// must not send a `no_endpoints` message before an `add` message; the client
// would clear its cached messages between the time it receives the
// `no_endpoints` message and the time it receives the `add` message, which is
// not the desired behavior.

service Destination {
  // Given a destination, return all addresses in that destination as a long-
  // running stream of updates.
  rpc Get(GetDestination) returns (stream Update) {}

  // Given a destination, return that destination's profile and send an update
  // whenever it changes.
  rpc GetProfile(GetDestination) returns (stream DestinationProfile) {}
}

message GetDestination {
  string scheme = 1;
  string path = 2;
}

message Update {
  oneof update {
    // A new set of endpoints are available for the service. The set might be
    // empty.
    WeightedAddrSet add = 1;

    // Some endpoints have been removed from the service.
    AddrSet remove = 2;

    // `no_endpoints{exists: false}` indicates that the service does not exist
    // and the client MAY try an alternate service discovery method (e.g. DNS).
    //
    // `no_endpoints(exists: true)` indicates that the service does exist and
    // the client MUST NOT fall back to an alternate service discovery method.
    NoEndpoints no_endpoints = 3;
  }
}

message AddrSet {
  repeated net.TcpAddress addrs = 1;
}

message WeightedAddrSet {
  repeated WeightedAddr addrs = 1;
  map<string, string> metric_labels = 2;
}

message WeightedAddr {
  net.TcpAddress addr = 1;
  uint32 weight = 3;
  map<string, string> metric_labels = 4;
  TlsIdentity tls_identity = 5;
  ProtocolHint protocol_hint = 6;
}

// Which strategy should be used for verifying TLS.
message TlsIdentity {
  oneof strategy {
    K8sPodIdentity k8s_pod_identity = 2;
  }

  // Verify the certificate based on the Kubernetes pod identity.
  message K8sPodIdentity {
    // The pod_identity string is of the format:
    // {owner_name}.{owner_type}.{pod_ns}.linkerd-managed.{controller_ns}.svc.cluster.local
    string pod_identity = 1;
    // The Kubernetes namespace of the pod's Linkerd2 control plane.
    string controller_ns = 2;
  }
}

message NoEndpoints {
  bool exists = 1;
}

// A hint of what protocol the service knows. The default value is
// for the `hint` field to be not be set, essentially meaning "unknown".
message ProtocolHint {
  oneof protocol {
    // Hints that the service understands HTTP2 and the proxy's internal
    // http2-upgrade mechanism.
    H2 h2 = 1;
  }

  message H2 {}
}

message DestinationProfile {
  // A list of routes, each with a RequestMatch.  If a request matches
  // more than one route, the first match wins.
  repeated Route routes = 1;
  // The retry budget controls how much additional load the proxy can generate
  // as retries.  Failured requets on retryable routes will not be retried if
  // there is no available budget.
  RetryBudget retry_budget = 2;
  // The retry timeout to use if none is specified by the route.
  google.protobuf.Duration default_retry_timeout = 3;
}

message Route {
  // This route contains requests which match this condition.
  RequestMatch condition = 1;
  // A list of response classes for this route.  If a response matches
  // more than one ResponseClass, the first match wins.  If a response does not
  // match any ResponseClasses, it is considered to be a successful response.
  repeated ResponseClass response_classes = 2;
  // Metric labels to attach to requests and responses that match this route.
  map<string, string> metrics_labels = 3;
  // If a route is retryable, any failed requests on that route may be retried
  // by the proxy.
  bool is_retryable = 4;
  // After this time has elapsed since receiving the initial request, no more
  // retries will be attempted.
  google.protobuf.Duration retry_timeout = 5;
}

message RetryBudget {
  // The ratio of additional traffic that may be added by retries.  A
  // retry_ratio of 0.1 means that 1 retry may be attempted for every 10 regular
  // requests.  A retry_ratio of 1.0 means that 1 retry may be attempted for
  // every 1 regular request (in other words, total request load may be doubled
  // as a result of retries).
  float retry_ratio = 1;
  // The proxy may always attempt this number of retries per second, even if it
  // would violate the retry_ratio.  This is to allow retries to happen even
  // when the request rate is very low.
  uint32 min_retries_per_second = 2;
  // This duraiton indicate for how long requests should be considered for the
  // purposes of enforcing the retry_ratio.  A higher value considers a larger
  // window and therefore allows burstier retries.
  google.protobuf.Duration ttl = 3;
}

message ResponseClass {
  // This class contains responses which match this condition.
  ResponseMatch condition = 1;
  // If responses in this class should be considered failures.  This defaults
  // to false (success).
  bool is_failure = 2;
}

message RequestMatch {
  message Seq {
    repeated RequestMatch matches = 1;
  }

  oneof match {
    Seq all = 1;
    Seq any = 2;
    RequestMatch not = 3;

    PathMatch path  = 4;
    http_types.HttpMethod method = 5;
    //TODO: match on arbitrary header
  }
}

message PathMatch {
  // Match if the request path matches this regex.
  string regex = 1;
}

message ResponseMatch {
  message Seq {
    repeated ResponseMatch matches = 1;
  }

  oneof match {
    Seq all = 1;
    Seq any = 2;
    ResponseMatch not = 3;

    HttpStatusRange status  = 4;
    //TODO: match on arbitrary header or trailer
  }
}

// If either a minimum or maximum is not specified, the range is considered to be
// over a discrete value.
message HttpStatusRange {
  // Minimum matching http status code (inclusive), if specified.
  uint32 min = 1;
  // Maximum matching http status code (inclusive), if specified.
  uint32 max = 2;
}

